{"pages":[{"title":"about","permalink":"/about/index.html","text":"我是来自火星的"},{"title":"标签","permalink":"/tags/index.html","text":""},{"title":"分类","permalink":"/categories/index.html","text":""}],"posts":[{"title":"IntelliJ DEBUG技巧 - 不中断执行输出日志","permalink":"/2017/05/01/IntelliJ-DEBUG技巧-不中断执行输出日志/","text":"IntelliJ的断点调试功能非常实用，不论是在本地还是远程调试都能非常节省我们的时间。但是，有时候我们需要调试一些在多线程环境下执行的程序时，我们使用断点并中断执行很容易造成与预期执行不一致。一般情况下，我们会添加一些日志，然后重新编译执行程序来查看日志的输出情况。 这次，我们可以通过IntelliJ的一个高级功能来实现不中断，不修改代码的情况下输出我们想要的日志内容。 首先，我们跟往常一样创建一个断点并右击断点后点击more。 ￼ 在断点详情窗口中，我们需要勾掉suspend中断线程的功能。接着，勾上Log evaluated expression并在厦门输入框中输入我们需要输出的日志内容。 ￼ 这样，再次执行对应的操作之后，我们在控制台中就能看到我们追加的日志了。"},{"title":"ES6里面箭头函数跟匿名函数的不同点","permalink":"/2017/04/11/ES6里面箭头函数跟匿名函数的不同点/","text":"ES6里面添加了一个非常好用的=&gt;箭头函数。不过，虽然这个新的写法可以减少我们开发时的代码量，但是这个函数对this解释有一些不同。 首先我们来看看=&gt;箭头函数的一些使用方式。 123456789//无参_.each([9], () =&gt; console.log(&quot;Hello&quot;));// output: Hello//单参_.each([9], (v) =&gt; console.log(&quot;Hello&quot;, v));// output: Hello 9//多参_.each([9], (v, index) =&gt; console.log(&quot;Hello&quot;, v, index));// output: Hello 9 0 本文重点，=&gt;箭头函数对this的解释。 如下面的代码所示， 匿名函数，this由于闭包的关系不同于函数外部的this对象，同时就造成了无法访问外部变量。 箭头函数，函数内的this对象与外部相同，可以同时访问外部变量。 1234567891011121314151617181920212223242526272829303132333435363738394041var _ = require(&quot;lodash&quot;);var demo = &#123; name: &quot;demo&quot;, values: [], add(values)&#123; console.log(&quot;add.name:&quot;, this.name);// demo _.each(values, value =&gt; &#123; console.log(&quot;add.name:inFunc:&quot;, this.name);// demo this.values.push(value); &#125;); &#125;, addOld(values)&#123; var self = this; console.log(&quot;addOld.name:&quot;, this.name);// demo _.each(values, function (value) &#123; // We should hack the &quot;this&quot; object. // Couldn&apos;t get the &quot;name&quot; property from &quot;this&quot; object. console.log(&quot;addOld.name:inFunc:&quot;, this.name);// demo self.values.push(value); &#125;); &#125;&#125;;demo.add([1, 2, 3]);demo.addOld([4, 5, 6]);console.log(demo.values);/*===========output===========add.name: demoadd.name:inFunc: demoadd.name:inFunc: demoadd.name:inFunc: demoaddOld.name: demoaddOld.name:inFunc: undefinedaddOld.name:inFunc: undefinedaddOld.name:inFunc: undefined[ 1, 2, 3, 4, 5, 6 ]===========output===========* */"},{"title":"在Spring中使用H2内存数据库","permalink":"/2017/03/16/在Spring中使用H2内存数据库/","text":"添加类库在pom.xml中添加如下两个类库 123456789&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.h2database&lt;/groupId&gt; &lt;artifactId&gt;h2&lt;/artifactId&gt; &lt;version&gt;1.4.192&lt;/version&gt;&lt;/dependency&gt; 初始数据接着我们还需要配置系统启动后的初始数据 ￼ schema.sql正如文件名一样，这个里面存放我们数据库结构的sql语句。 12345678910111213141516-- MySQL Workbench Synchronization-- Generated: 2017-03-15 19:03-- Model: New Model-- Version: 1.0-- Project: Name of the project-- Author: jinCREATE TABLE IF NOT EXISTS tb_user ( tid BIGINT(20) NOT NULL AUTO_INCREMENT, name VARCHAR(60) NOT NULL, pass VARCHAR(255) NOT NULL, email VARCHAR(255) NOT NULL, PRIMARY KEY (tid))ENGINE = InnoDBDEFAULT CHARSET=utf8; data.sql在数据库结构创建成功后，我们还需要通过这个文件来初始化我们的数据。 1INSERT INTO tb_user (name, pass, email) VALUES (&apos;jin&apos;, &apos;1234&apos;, &apos;jin@isr.co.jp&apos;); spring配置准备完上面的步骤，最后我们还需要配置application.properties文件 12345678910111213141516#在使用datasource的schema&amp;data来初始化数据时，我们需要关闭hibernate的自动创建功能spring.jpa.hibernate.ddl-auto=nonespring.datasource.schema=classpath:db/schema.sqlspring.datasource.data=classpath:db/data.sqlspring.datasource.initialize=true#想要开启h2控制台的话可以指定下面两个配置，这是一个类似phAdmin的工具，操作界面看下图spring.h2.console.path=/h2-consolespring.h2.console.enabled=true#当然不能忘记添加数据库连接#这里我们有个技巧，利用系统变量来配置我们的用户名跟密码#这样我们就不会提交密码到版本控制器里面了spring.datasource.url=jdbc:h2:mem:test;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE;IGNORECASE=TRUEspring.datasource.driver-class-name=org.h2.Driverspring.datasource.username=$&#123;jin_user&#125;spring.datasource.password= 浏览器中访问：http://localhost:8080/h2-console 并登录后 ￼ 这样，你所有的h2数据库配置就已经完成了，接下来你就可以添加repository来操作这个数据库了。"},{"title":"Java 中的变长参数","permalink":"/2017/03/09/Java-中的变长参数/","text":"在 Java 5 中提供了变长参数，允许在调用方法时传入不定长度的参数。变长参数是Java的一个语法糖，本质上还是基于数组的实现。 12void foo(String... args);void foo(String[] args); 12//方法签名([Ljava/lang/String;)V // public void foo(String[] args) 从方法的签名可以看到，变长参数在编译为字节码后，在方法签名中就是以数组形态出现的。这两个方法的签名是一致的，不能作为方法的重载。如果同时出现，是不能编译通过的。可变参数可以兼容数组，反之则不成立。 123456public void foo(String...varargs)&#123;&#125;foo(&quot;arg1&quot;, &quot;arg2&quot;, &quot;arg3&quot;);//上述过程和下面的调用是等价的foo(new String[]&#123;&quot;arg1&quot;, &quot;arg2&quot;, &quot;arg3&quot;&#125;); 使用规则优先匹配固定参数12345678910void foo(String arg1, String arg2) &#123; System.out.println(&quot;invoke first method!&quot;);&#125;void foo(String... args) &#123; System.out.println(&quot;invoke second method!&quot;);&#125;foo(&quot;arg1&quot;, &quot;arg2&quot;); //invoke first method!foo(&quot;arg1&quot;, &quot;arg2&quot;, &quot;arg3&quot;); //invoke second method! 如果同时匹配多个可变参数，无法编译通过123456789void foo(String arg1, String... args) &#123; System.out.println(&quot;invoke first method!&quot;);&#125;void foo(String... args) &#123; System.out.println(&quot;invoke second method!&quot;);&#125;foo(&quot;arg1&quot;);//compile error 可变参数只能有一个，且必须在参数列表最后 规范在使用变长参数时，有必要遵循一些规范，使得别人更容易理解你的代码。以下三个建议来自「编写高质量代码：改善Java程序的151个建议」一书。 避免带有变长参数的方法重载即便编译器可以按照优先匹配固定参数的方式确定具体的调用方法，但在阅读代码的依然容易掉入陷阱。要慎重考虑变长参数的方法重载。 别让null值和空值威胁到变长方法123456789101112131415public class Client &#123; public void methodA(String str,Integer... is)&#123; &#125; public void methodA(String str,String... strs)&#123; &#125; public static void main(String[] args) &#123; Client client = new Client(); client.methodA(&quot;China&quot;, 0); client.methodA(&quot;China&quot;, &quot;People&quot;); client.methodA(&quot;China&quot;); //compile error client.methodA(&quot;China&quot;,null); //compile error &#125; &#125; 修改如下： 12345public static void main(String[] args) &#123; Client client = new Client(); String[] strs = null; client.methodA(&quot;China&quot;,strs); &#125; 让编译器知道这个null值是String类型的，编译即可顺利通过，也就减少了错误的发生。 覆写变长方法也要循规蹈矩在子类中覆写父类的方法，需要满足以下几个条件： 覆写方法不能缩小访问权限。参数列表必须与被覆写方法相同。返回类型必须与被覆写方法的相同或是其子类。覆写方法不能抛出新的异常，或者超出父类范围的异常，但是可以抛出更少、更有限的异常，或者不抛出异常。我们看一下下面的这个例子： 123456789101112131415161718192021222324public class Client &#123; public static void main(String[] args) &#123; //向上转型 Base base = new Sub(); base.fun(100, 50); //不转型 Sub sub = new Sub(); sub.fun(100, 50); //compile error &#125; &#125; //基类 class Base&#123; void fun(int price, int... discounts)&#123; System.out.println(&quot;Base......fun&quot;); &#125; &#125; //子类，覆写父类方法 class Sub extends Base&#123; @Override void fun(int price, int[] discounts)&#123; System.out.println(&quot;Sub......fun&quot;); &#125; &#125; 子类中覆写父类的方法是没有问题的，因为方法的签名是一致的，父类的 fun 方法中 int… 参数在编译成字节码后是 int[]， 子类在参数列表中直接使用 int[] 是一致的。然而在编译时 main 方法中第二个调用却会出错。 这太奇怪了：子类继承了父类的所有属性和方法，甭管是私有的还是公开的访问权限，同样的参数、同样的方法名，通过父类调用没有任何问题，通过子类调用却编译通不过，为啥？难道是没继承下来？或者子类缩小了父类方法的前置条件？那如果是这样，就不应该覆写，@Override就应该报错，真是奇妙的事情！ 事实上，base对象是把子类对象Sub做了向上转型，形参列表是由父类决定的，由于是变长参数，在编译时，“base.fun(100, 50)”中的“50”这个实参会被编译器“猜测”而编译成“{50}”数组，再由子类Sub执行。我们再来看看直接调用子类的情况，这时编译器并不会把“50”做类型转换，因为数组本身也是一个对象，编译器还没有聪明到要在两个没有继承关系的类之间做转换，要知道Java是要求严格的类型匹配的，类型不匹配编译器自然就会拒绝执行，并给予错误提示。 这是个特例，覆写的方法参数列表与父类不完全相同，这违背了覆写的定义，并且会引发莫名其妙的错误。所以在对变长参数进行覆写时，如果要使用此类似的方法，请仔细想想是不是一定要如此。在进行方法覆写的时候，方法参数要与父类完全一致，不仅仅是类型、数量，还包括显示形式。 可能会踩的坑使用 Object… 作为变长参数1234567891011public void foo(Object... args) &#123; System.out.println(args.length);&#125;foo(new String[]&#123;&quot;arg1&quot;, &quot;arg2&quot;, &quot;arg3&quot;&#125;); //3foo(100, new String[]&#123;&quot;arg1&quot;, &quot;arg1&quot;&#125;); //2foo(new Integer[]&#123;1, 2, 3&#125;); //3foo(100, new Integer[]&#123;1, 2, 3&#125;); //2foo(1, 2, 3); //3foo(new int[]&#123;1, 2, 3&#125;); //1 int[] 无法转型为 Object[], 因而被当作一个单纯的数组对象 ; Integer[] 可以转型为 Object[], 可以作为一个对象数组。 反射方法调用时的注意事项123456789101112131415161718public class Test &#123; public static void foo(String... varargs)&#123; System.out.println(args.length); &#125; public static void main(String[] args)&#123; String[] varArgs = new String[]&#123;&quot;arg1&quot;, &quot;arg2&quot;&#125;; try&#123; Method method = Test.class.getMethod(&quot;foo&quot;, String[].class); method.invoke(null, varArgs); method.invoke(null, (Object[])varArgs); method.invoke(null, (Object)varArgs); method.invoke(null, new Object[]&#123;varArgs&#125;); &#125; catch (Exception e)&#123; e.printStackTrace(); &#125; &#125;&#125; 上面的四个调用中，前两个都会在运行时抛出java.lang.IllegalArgumentException: wrong number of arguments异常，后两个则正常调用。 反射是运行时获取的，在运行时看来，可变长参数和数组是一致的，因而方法签名为： 12//方法签名([Ljava/lang/String;)V // public void foo(String[] varargs) 再来看一下 Method 对象的方法声明： 1Object invoke(Object obj, Object... args) args 虽然是一个可变长度的参数，但是 args 的长度是受限于该方法对象代表的真实方法的参数列表长度的，而从运行时签名来看，([Ljava/lang/String;)V实际上只有一个形参，即String[] varargs，因而invoke(Object obj, Object... args)中可变参数 args 的实参长度只能为1。 123456//Object invoke(Object obj, Object... args)//String[] varArgs = new String[]&#123;&quot;arg1&quot;, &quot;arg2&quot;&#125;;method.invoke(null, varArgs); //varArgs长度为2，错误method.invoke(null, (Object[])varArgs); //将String[]转换为Object[],长度为2的，错误method.invoke(null, (Object)varArgs);//将整个String[] 转为Object，长度为1，符合method.invoke(null, new Object[]&#123;varArgs&#125;);//Object[]长度为1，正确。上一个和这个是等价的 什么时候使用可变长参数？Stack Overflow上有个关于变长参数使用的问题。简单地说，在不确定方法需要处理的对象的数量时可以使用可变长参数，会使得方法调用更简单，无需手动创建数组 new T[]{…} 。"},{"title":"Vagrant使用说明1","permalink":"/2017/01/05/Vagrant使用说明1/","text":"Create and configure lightweight, reproducible, and portable development environments. 正如官网所描述的一样Vagrant是一个类似于docker能用来快速的配置锁需要的开发环境，而不收到每台机子自身环境的影响。 基本使用Vagrant有下列基本使用命令来控制管理虚拟机： 执行方式： vagrant up 启动虚拟机 halt 关闭虚拟机 suspend 暂停虚拟机，虚拟机内存等信息将以文件的方式保存在本地，可以通过执行恢复操作来继续使用 resume 恢复虚拟机，与前面的暂停相对应 destroy 删除虚拟机，会删除当前虚拟机，但是Vagrantfile文件会被保留 实际使用1.下载并添加box 1234#将指定位置（./precise32.box）的box以`“precise32”`的名字添加到本地box中vagrant box add precise32 ./precise32.box#查看本地box列表vagrant box list 2.创建一个虚拟机 123mkdir ~/temp/testcd ~/temp/testvagrant init 执行以上命令后，会在temp/test目录下自动生成一个Vagrantfile文件，下面的例子是创建一个名为web1的私有网络服务器192.168.50.4（只能被本机访问） Vagrantfile 123456789VAGRANTFILE_API_VERSION = &quot;2&quot;Vagrant.configure(VAGRANTFILE_API_VERSION) do |config| config.vm.define &quot;web1&quot; do |web1| web1.vm.box = &quot;precise32&quot; web1.vm.network &quot;private_network&quot;, ip: &quot;192.168.50.4&quot; endend 然后在当前目录下启动服务器并通过ssh登录到虚拟机内 12vagrant upvagrant ssh 3.打包已配置的环境 当然，我们的最终目的是团队间共享同一个开发环境，那么我们就必须要用到打包功能。Vagrant提供了一个很简单的命令，来打包我们配置号的开发环境。 123#首先，还是进入到虚拟机目录，然后执行下面命令#我们将当前目录打包成一个web.box文件vagrant package --output web.box"},{"title":"lodash - 使用笔记","permalink":"/2016/04/11/lodash-使用笔记/","text":"transform（转换）官方API说明 _.transform(object, [iteratee=_.identity], [accumulator]) Arguments object (Array|Object): The object to iterate over. [iteratee=_.identity] (Function): The function invoked per iteration. [accumulator] (*): The custom accumulator value. Returns (*): Returns the accumulated value. 例子： 123456789101112131415161718//筛选所有2的倍数_.transform([2, 3, 4, 6], function(result, n) &#123; n % 2 == 0 &amp;&amp; result.push(n);&#125;, []);// → [2, 4, 6]//筛选2个2的倍数_.transform([2, 3, 4, 6], function(result, n) &#123; n % 2 == 0 &amp;&amp; result.push(n); //结束循环 if(result.length == 2) return false;&#125;, []);// → [2, 4]//反转Key跟Value_.transform(&#123; 'a': 1, 'b': 2, 'c': 1 &#125;, function(result, value, key) &#123; (result[value] || (result[value] = [])).push(key);&#125;, &#123;&#125;);// → &#123; '1': ['a', 'c'], '2': ['b'] &#125;"},{"title":"EMCAScript6：下一版本的JavaScript的新特性","permalink":"/2016/04/11/EMCAScript6：下一版本的JavaScript的新特性/","text":"你可能已经听说过EMCAScript6（ES6）了，这是下一个版本的Javascript，它包含了一些很棒的新特性。这些特性拥有不同程度的复杂性，对于简单的脚本和复杂的应用程序都非常的有用。本文将盘点一些ES6的新特性，这些特性都可以用在你日常的编码中。 请注意，只有现代浏览器才能支持这些新的ES6特性，虽然浏览器的支持各不相同。如果你需要兼容那些不支持ES6新特性的旧浏览器，我也会谈谈关于这方面的解决方案。 变量LET通常我们使用var关键字来声明变量，现在我们同样可以使用let，它们之间的细微差别在于作用域。使用var声明变量时，该变量的作用域是其最近的函数，而使用let声明变量，它的作用域只在包含它的块。 1234if(true) &#123; let x = 1;&#125;console.log(x); // undefined 这样可以让代码更加干净整洁，可以减少无用的变量。 看看下面这个经典的数组循环： 12345for(let i = 0, l = list.length; i &lt; l; i++) &#123; // do something with list[i]&#125;console.log(i); // undefined 举个例子，经常会有人使用变量j在同一作用域中的另外一个循环中。但是使用let声明变量，你可以很安全地再声明一次，因为它只在自己块级作用域内定义和有效。 CONST声明块级作用域内的变量的另一种方法是使用const。使用const，你可以声明一个只读的值，必须直接指定一个值，如果尝试改变它的值或者没有立即指定一个值，就会得到下面的错误： 123const MY_CONSTANT = 1;MY_CONSTANT = 2 // Errorconst SOME_CONST; // Error 注意，你还是可以修改对象的属性或者数组的成员 12const MY_OBJECT = &#123;some: 1&#125;;MY_OBJECT.some = &apos;body&apos;; // Cool 箭头函数箭头函数对于Javascript来说是一个非常棒的补充，它可以让代码更加精简。我们首先来介绍箭头函数，在稍后的其他例子中就会使用到它的优点。下面的代码展示了一个箭头函数和我们熟悉的ES5风格的两种写法的函数： 12345678let books = [&#123;title: &apos;X&apos;, price: 10&#125;, &#123;title: &apos;Y&apos;, price: 15&#125;];let titles = books.map( item =&gt; item.title );// ES5 equivalent:var titles = books.map(function(item) &#123; return item.title;&#125;); 我们来看看箭头函数的语法，其中没有function关键字，剩下的就是0个或多个参数、(=&gt;)箭头和函数表达式。注意：return语句将隐式地被添加进来。 如果是0个或多个参数，必须添加括号： 12345// No argumentsbooks.map( () =&gt; 1 ); // [1, 1]// Multiple arguments[1,2].map( (n, index) =&gt; n * index ); // [0, 2] 如果需要更多的逻辑或者空白区域，可以将函数表达式放在({…})块中。 1234let result = [1, 2, 3, 4, 5].map( n =&gt; &#123; n = n % 3; return n;&#125;); 箭头函数不仅仅意味着更少的字符，它的行为也不同于常规的函数。一个箭头函数从它的外界上下文中继承this和arguments关键字。这表示你可以摆脱以前那些难看的语句，比如var that = this，而且不需要绑定函数到正确的上下文中。下面有一个例子（注意：this.title等同于ES5版本的that.title）： 12345678910111213141516171819let book = &#123; title: &apos;X&apos;, sellers: [&apos;A&apos;, &apos;B&apos;], printSellers() &#123; this.sellers.forEach(seller =&gt; console.log(seller + &apos; sells &apos; + this.title)); &#125;&#125;// ES5 equivalent:var book = &#123; title: &apos;X&apos;, sellers: [&apos;A&apos;, &apos;B&apos;], printSellers: function() &#123; var that = this; this.sellers.forEach(function(seller) &#123; console.log(seller + &apos; sells &apos; + that.title) &#125;) &#125;&#125; 字符串方法String的prototype中添加了几个方便的方法，大部分是indexOf方法的变通： 123&apos;my string&apos;.startsWith(&apos;my&apos;); //true&apos;my string&apos;.endsWith(&apos;my&apos;); // false&apos;my string&apos;.includes(&apos;str&apos;); // true 简单有效！另外，还添加了一个方便创建重复字符串的方法： 1&apos;my &apos;.repeat(3); // &apos;my my my &apos; 模板字符串模板字符串提供了一个简洁的方式去创建字符串和实现字符串插值。你可能已经熟悉了它的语法，模板字符串基于美元符号和花括号${…}，并且要使用反引号(`)将其包围。 下面是一个简单的演示： 1234567891011let name = &apos;John&apos;, apples = 5, pears = 7, bananas = function() &#123; return 3; &#125;console.log(`This is $&#123;name&#125;.`);console.log(`He carries $&#123;apples&#125; apples, $&#123;pears&#125; pears, and $&#123;bananas()&#125; bananas.`);// ES5 equivalent:console.log(&apos;He carries &apos; + apples + &apos; apples, &apos; + pears + &apos; pears, and &apos; + bananas() +&apos; bananas.&apos;); 上面的示例中，和ES5相比较，模板字符串仅仅只是方便字符串的串联。模板字符串通常应用于多行字符串，请记住，空白是字符串的一部分。 12345678910let x = `1...2...3 lines long!`; // Yay// ES5 equivalents:var x = &quot;1...\\n&quot; + &quot;2...\\n&quot; +&quot;3 lines long!&quot;;var x = &quot;1...\\n2...\\n3 lines long!&quot;; 数组Array对象现在新增了一些静态方法以及prototype上的一些方法。 第一、Array.from方法从类数组或可迭代对象上创建Array的实例。类数组对象的例子包括： 函数中的arguments对象 document.getElementsByTagName放回的一个nodeList对象 新的Map和Set数据结构 12345678let itemElements = document.querySelectorAll(&apos;.items&apos;);let items = Array.from(itemElements);items.forEach(function(element) &#123; console.log(element.nodeType)&#125;);// A workaround often used in ES5:let items = Array.prototype.slice.call(itemElements); 上面的示例中，可以看出items数组拥有forEach方法，但是在itemElements集合中，这个方法是不可用的。 Array.from有一个有趣的特性是它的第二个可选参数mapFunction，这个参数允许在单次调用中创建一个新的映射数组。 12let navElements = document.querySelectorAll(&apos;nav li&apos;);let navTitles = Array.from(navElements, el =&gt; el.textContent); 第二、Array.of方法，这个方法的行为有点像Array的构造函数，它修复了传递单个数字参数时的特殊情况，所以Array.of相比于new Array()更好。不过大多数情况下，我们推荐使用数组字面量。 123let x = new Array(3); // [undefined, undefined, undefined]let y = Array.of(8); // [8]let z = [1, 2, 3]; // Array literal 最后，Array的prototype中添加了几个方法，其中的find方法我觉得Javascript开发者将会非常喜欢。 find方法：获取回调函数return true的第一个元素。 findIndex方法：获取回调函数return true的第一个元素的索引 fill方法：根据给定的参数重写数组的元素 123456[5, 1, 10, 8].find(n =&gt; n === 10) // 10[5, 1, 10, 8].findIndex(n =&gt; n === 10) // 2[0, 0, 0].fill(7) // [7, 7, 7][0, 0, 0, 0, 0].fill(7, 1, 3) // [0, 7, 7, 7, 0] MathMath对象也添加了几个方法。 Math.sign 返回一个数字的符号，有1，-1或0三个值分别表示正值，负值或0 Math.trunc 返回一个数字去掉小数位数后的数 Math.cbrt 返回一个数字的立方根 1234567Math.sign(5); // 1Math.sign(-9); // -1Math.trunc(5.9); // 5Math.trunc(5.123); // 5Math.cbrt(64); // 4 如果你想要学习更多的新的Math内容，点击new number and math features in ES6。 扩展操作符扩展操作符(…)是一个非常方便的语法，它用于在数组的特殊的地方扩展元素，比如函数调用中的参数。下面展示一些例子来说明它的用处。 首先，我们来看看如何通过另一个数组来扩展数组的元素： 12345678let values = [1, 2, 4];let some = [...values, 8]; // [1, 2, 4, 8]let more = [...values, 8, ...values]; // [1, 2, 4, 8, 1, 2, 4]// ES5 equivalent:let values = [1, 2, 4];// Iterate, push, sweat, repeat...// Iterate, push, sweat, repeat... 当使用参数调用函数时，扩展操作符同样非常强大。 12345678910let values = [1, 2, 4];doSomething(...values);function doSomething(x, y, z) &#123; // x = 1, y = 2, z = 4&#125;// ES5 equivalent:doSomething.apply(null, values); 正如你所看到的，这避免了我们经常使用的fn.apply()这种委婉曲折的方式。扩展操作符语法非常灵活，因为它可以在参数列表的任何地方使用，即下面的调用方式也会产生一样的结果： 12let values = [2, 4];doSomething(1, ...values); 我们已经将扩展操作符应用到Array和arguents中了。实际上，所有的可迭代的对象都可以应用扩展操作符，比如NodeList： 12345let form = document.querySelector(&apos;#my-form&apos;), inputs = form.querySelectorAll(&apos;input&apos;), selects = form.querySelectorAll(&apos;select&apos;);let allTheThings = [form, ...inputs, ...selects]; 现在allTheThings变成一个扁平的数组，其中包含form节点，input和select的子节点。 解构解构提供了一个便捷的方式来从对象或数组中提取数据。下面给了一个使用数组的典型例子。 123456let [x, y] = [1, 2]; // x = 1, y = 2// ES5 equivalent:var arr = [1, 2];var x = arr[0];var y = arr[1]; 使用这种语法，可以一次性指定多个变量。还有另外一个作用是可以很简单的交换两个变量值。 1234let x = 1, y = 2;[x, y] = [y, x]; // x = 2, y = 1 解构也能用于对象上，要保证key值匹配。 12let obj = &#123;x: 1, y: 2&#125;;let &#123;x, y&#125; = obj; // x = 1, y = 2 也可以通过这个机制来修改变量的名称 12let obj = &#123;x: 1, y: 2&#125;;let &#123;x: a, y: b&#125; = obj; // a = 1, b = 2 还有另外一个有趣的用法是模拟多个返回值 12345function doSomething() &#123; return [1, 2]&#125;let [x, y] = doSomething(); // x = 1, y = 2 解构同样也可以指定argument对象的默认值，通过字面量对象，可以模拟命名参数。 1234function doSomething(&#123;y = 1, z = 0&#125;) &#123; console.log(y, z);&#125;doSomething(&#123;y: 2&#125;); 参数默认值在ES6中，是可以给函数参数定义一个默认值的，语法如下： 1234567function doSomething(x, y = 2) &#123; return x * y;&#125;doSomething(5); // 10doSomething(5, undefined); // 10doSomething(5, 3); // 15 这样看起来就简洁多了，如果是ES5之前的写法，我们肯定要补充一些参数： 1234function doSomething(x, y) &#123; y = y === undefined ? 2 : y; return x * y;&#125; undefined或者无参时将会触发参数的默认值。 剩余不定参数我们已经看过了扩展操作符，不定参数与其非常相似。不定参数也使用…语法，它允许将函数末端的参数存储在一个数组里面。 12345function doSomething(x, ...remaining) &#123; return x * remaining.length;&#125;doSomething(5, 0, 0, 0); // 15 模块模块是Javascript中非常受欢迎的一个补充，我认为它是ES6中非常值得挖掘的一个特性。 现如今，任何重要的JS项目都会使用某种模块系统-可能是“暴露型模块模式”或者更广泛的AMD和Common.js。但是，浏览器是没有任何模块系统的特性的，总是需要为AMD或CommonJS模块构建加载模块，处理这些的工具包括RequireJS，Browserify和Webpack。 ES6规范中同时包含了模块中的语法和加载机制。如果你想要在以后使用模块，应该使用下面的语法。现代的构建工具可以通过插件支持这种格式，所以我们可以尽管去使用它。（不用担心，我们在后面的“Transpilation”章节中会讨论这个问题）。 现在，在ES6的模块语法中，模块被设计成使用export和import两个关键字，我们来看看示例中的两个模块。 12345678910// lib/math.jsexport function sum(x, y) &#123; return x + y;&#125;export var pi = 3.141593;// app.jsimport &#123; sum, pi &#125; from &quot;lib/math&quot;;console.log(&apos;2π = &apos; + sum(pi, pi)); 如你所见，代码中有多个export语句。每一个都必须显式地声明输出的值，在这个例子中，就是function和var。 示例中的import语句使用了一个语法（类似于解构）来显式地定义了输出的内容。要将整个模块一起输出，可以使用通配符“*”，结合as关键字给模块一个本地名称。 1234// app.jsimport * as math from &quot;lib/math&quot;;console.log(&apos;2π = &apos; + math.sum(math.pi, math.pi)); 模块系统有一个默认模块，它也可以是函数。要导出模块内的默认值，需要提供一个本地名称： 12345678910// lib/my-fn.jsexport default function() &#123; console.log(&apos;echo echo&apos;);&#125;// app.jsimport doSomething from &apos;lib/my-fn&apos;;doSomething(); 注意：import语句是同步的，但是它会等到所有依赖的加载完毕才会执行。 Classes类是ES6中讨论得很多的一个特性。一些人类违反了JS的原型性质，而其他人觉得这降低了初学者和来自其他开发语言的开发者的入门门槛，并且能够帮助他们编写大规模应用。无论如何，它都是ES6中的一部分，我们简单地介绍一下。 我们通过class和constructor关键字构建类，下面是一个简短的示例： 123456789101112class Vehicle &#123; constructor(name) &#123; this.name = name; this.kind = &apos;vehicle&apos;; &#125; getName() &#123; return this.name; &#125; &#125;// Create an instancelet myVehicle = new Vehicle(&apos;rocky&apos;); 注意：类的定义并不是一个普通的对象，因此类成员之间没有使用逗号来分隔。 从一个类创建实例必须使用new关键字，而从一个基类继承则使用extends： 123456789101112class Car extends Vehicle &#123; constructor(name) &#123; super(name); this.kind = &apos;car&apos; &#125;&#125;let myCar = new Car(&apos;bumpy&apos;);myCar.getName(); // &apos;bumpy&apos;myCar instanceof Car; // truemyCar instanceof Vehicle; //true 在派生类中，可以使用super关键字来访问基类的构造函数或方法： 1、要访问基类构造函数，使用super()2、要访问基类中的方法，是用super.getName() 类还有更多的用法，如果想要深入地学习这方面，可以看看Classes in ECMAScript6 SymbolSymbol是一种新的原始数据类型，和Number、String一样。我们可以使用symbol来给对象创建唯一的ID或唯一的常量。 1234const MY_CONSTANT = Symbol();let obj = &#123;&#125;;obj[MY_CONSTANT] = 1; 注意：Object.getOwnPropertyNames方法不会返回Symbol生成键值，在for..in循环中，Object.keys()和JSON.stringify()也是不可见的，这是与普通的字符串key值的区别所在。我们可以通过Object.getOwnPropertySymbols()获取对象中的symbol数组。 因为不可变的特点，Symbols常常与const一起配合使用： 123456789101112131415161718const CHINESE = Symbol();const ENGLISH = Symbol();const SPANISH = Symbol();switch(language) &#123; case CHINESE: // break; case ENGLISH: // break; case SPANISH: // break; default: // break;&#125; 也可以给Symbol一段字符串来描述，虽然无法通过字符串来访问symbol本身，但是调试的时候很有用。 123456const CONST_1 = Symbol(&apos;my symbol&apos;);const CONST_2 = Symbol(&apos;my symbol&apos;);typeof CONST_1 === &apos;symbol&apos;; // trueCONST_1 === CONST_2; // false 想要学习更多的symbol内容可以查看symbol primitive Transpilation现在我们可以使用ES6来写代码了。前面介绍中提到的浏览器还没有广泛地支持ES6的特性，而且支持性各不相同。你的用户使用的浏览器很有可能不完全懂得解析ES6代码。所以我们要将这些代码转换成上一个版本的Javascript（ES5），它们可以很好地运行在现代浏览器上，这种转换通常被称为Transpilation。在浏览器支持ES6之前，都需要在我们的应用程序中做这一项转换。 开始转换代码并不困难，可以直接通过命令行转换代码，或者在Grunt和Gulp中作为一个Task包含在插件里面。有很多转换代码的方案，比如Babel，Traceur和TypeScript。可以看看这个使用Babel的例子many ways to start using ES6，很多ES6的特性都会进行处理。 那我们如何使用ES6呢？首先，根据你想要使用的ES6特性和你需要支持的浏览器或运行环境（比如Node.js）,在你的工作流中结合一个编译转换器。如果你希望的话，还有一些监视文件变化和浏览器实时刷新的插件来让你体验无缝的编码。 如果是从头开始，你可能只是想要使用命令行来转换代码（查看例子Babel CLI documentation）。如果你已经使用过grunt或gulp之类的工具，你可以添加一个比如gulp-babel的插件，或者Webpack中的babel-loader插件。对于Grunt，有一个grunt-babel，还有很多其他的ES6-related plugins。对于使用Browserify的开发者，可以看看babelify。 很多特性被转换成ES5的兼容性代码后，并不会有很大的开销，通过编译器提供的临时性方案会有一点点的性能损耗。你可以通过各种交互环境（也称作RELPs）来看看使用ES6代码和编译后的代码是什么样的： Traceur：website,REPL Babel：website,REPL TypeScript：website,REPL ScratchJS（chrome插件） 注意，TypeScript并不完全是一个转换器，它是强类型的Javascript的超集，可以编译成Javascript，它和其他转换器一样，支持很多ES6特性。 究竟如何使用？通常来说，一些ES6的特性可以自由地使用，比如模块、箭头函数，不定参数和类。这些特性不会用太多开销，就可以转换成ES5代码。而Array、String和Math对象上和原型上的方法（比如Array.from等等）需要所谓的“polyfills”。Polyfills是对那些浏览器还没有原生支持的特性的一个临时方案。你可以首先加载polyfills，如果浏览器有此函数，代码就会正常运行，Babel和Traceur都会提供类似的polyfills。 可以查看ES6兼容性表来看看转换器和浏览器对ES6新特性的支持情况。令人激动的是，在写这篇文章的时候，最新的浏览器已经支持了所有ES6特性的55%到70%。Microsoft Edge，Google Chrome和Mozilla Firefox相互竞争，这对整个Web的发展有很大的意义。 就我个人而言，我发现能够很简单地使用ES6中的新特性，比如模块，箭头函数和不定参数等等是一种解脱，也是对自己编码的一个显著的提升。现在我很享受使用ES6写代码，然后将其转换成ES5代码。ES6的优点随着时间的增长会越来越明显。 下一步呢？只要安装了一个转换器，就可以开始使用一些小的特性，比如let和箭头函数。记住，已经编写好的ES5代码，转换器会原封不动地保留下来。当你使用ES6去优化你的代码，慢慢地喜欢用它，你就可以逐步将越来越多的ES6特性应用到代码中。也许有一些代码会有新的模块或类语法，但是我保证一切都会越来越好的！ 除了文章中提到的特性，还有更多的ES6的东西没有被提到，比如Map，Set，标签模板字符串，生成器，Proxy和Promise，如果你想知道请关注后续的文章。另外，如果想要深入学习，我推荐Exploring ES6这本书，书里面提到了所有的ES6特性。 最后的思考通过使用转换器，所有的代码实际上是转换成了ES5。而浏览器一直在添加新特性，所以，即便浏览器完全支持某个特定的ES6特性，最后还是运行ES5兼容版本的代码，这样可能表现会更糟糕。你可以期待，在你需要兼容的浏览器和运行环境里，所有的ES6特性最终都会被支持。但是在那之前，我们需要管理好这些ES6特性的支持情况，选择性地禁用某些ES6特性来减少转换成ES5代码后带来的不必要的开销。知道了这些，你就可以决定是否要使用ES6中的特性。 译者信息 小骆，90后码农一个，潜水于互联网中，专注web开发，喜爱写代码，个人博客狼狼的蓝胖子 译文链接：http://www.codeceo.com/article/es6-next-javascript.html英文原文：ECMAScript 6 (ES6): What’s New In The Next Version Of JavaScript"},{"title":"hexo新建文档后自动打开","permalink":"/2016/04/08/hexo新建文档后自动打开/","text":"添加一篇新的文章非常简单，只需要输入下面命令： 1hexo new &quot;我是一篇新的文章&quot; 就可以了。然后Hexo会自动在source/_post下面给你创建一个新的markdown文件。但是，我们每次还找到这个目录并打开这个文件才能开始编辑。虽然不是很麻烦，但是如果这个步骤能自动帮我们做的话，那是不是就完美了呢？ 这时候，我们就需要用到Hexo支持的脚本功能。首先，我们在Hexo的目录下创建一个scripts文件夹，然后新增一个文件autoopen.js。接着我们打开autoopen.js后输入下面内容： 1234567891011var exec = require(&apos;child_process&apos;).exec;// Hexo 2.x//hexo.on(&apos;new&apos;, function(path)&#123;// exec(&apos;open &apos; + path);//&#125;);// Hexo 3.xhexo.on(&apos;new&apos;, function(data)&#123; exec(&apos;open &apos; + data.path);&#125;); 因为Hexo的2.x跟3.x版本传递的参数不同，所以，请自行选择自己对应的版本来添加。 最后，我们依然还是输入下面的命令： 1hexo new &quot;我是一篇新的文章&quot; 你会看到，markdown文件会被默认的软件给打开，这时候你只需要设置打开markdown文件的默认编辑器即可。（当然，你也可以在上面exec命令里面指定对应的软件）"},{"title":"ubuntu-服务器自动备份","permalink":"/2016/04/08/ubuntu-服务器自动备份/","text":"目录结构 12345.|-- .gitignore #git的过滤配置文件|-- backup.sh #备份脚本|-- db_backup #sql保存目录`-- myweb #站点 配置git 前提，需要配置服务器上访问远程git的权限，推荐ssh密钥方式。 1234cd ~/servergit init#如果需要的话，一定要记得配置.gitignore，可以讲一些不需要的文件去除掉git remote add origin git://example.com/example/example.git 备份脚本 首先我们需要准备一个sh脚本，用来导出db数据跟提交到git服务器上（由于数据库内容还不多，所以现在可以考虑备份到git上面） 12345678#!/bin/sh#请自行替换&lt;user&gt;，&lt;password&gt;，&lt;dbName&gt;mysqldump --opt --user=&lt;user&gt; --password=&lt;password&gt; &lt;dbName&gt; --skip-lock-tables &gt; &quot;./db_backup/db1.sql&quot;mysqldump --opt --user=&lt;user&gt; --password=&lt;password&gt; &lt;dbName&gt; --skip-lock-tables &gt; &quot;./db_backup/db2.sql&quot;git add .git commit -m &quot;auto backup&quot;git push origin master 计划任务 当然，我们配置好上面的代码之后，还不算结束。还需要配置一个定时任务，来定期执行这个备份脚本。（不然一直手动来执行的话，也会疯掉） 打开编辑crontab页面 1$ crontab -e 输入下列内容 12#backup myweb database &amp; web site0 1 * * * /usr/server/backup.sh 上面的任务是每天1点的时候执行那个backup.sh。 这样，我们就可以安心的去喝茶了。。。"},{"title":"APNS开发帮助","permalink":"/2016/04/07/apns-notice/","text":"在处理iOS应用的通知时，碰到很头疼的问题。因为iOS在只有在特定条件下才会触发didReceiveRemoteNotification方法，目前已知的有2种情况： App在前台激活状态 App在后台，收到通知时点击通知栏 因此，想要即使的反馈信息给用户的话，我们就需要在3个地方处理通知的问题： 第一个，应用启动时从服务器端获取数据（这个不用说了） 第二个，应用回到前台的时判断是否需要从服务器获取数据 第三个，在didReceiveRemoteNotification中判断application.applicationState == .Active时，从服务器获取最新数据。 1234567891011func application(application: UIApplication, didReceiveRemoteNotification userInfo: [NSObject : AnyObject]) &#123; if ( application.applicationState == .Active )&#123; //触发1 &#125; else &#123; //触发2 &#125;&#125;func applicationWillEnterForeground(application: UIApplication) &#123; //触发3&#125; 条件 动作 didReceiveRemoteNotification applicationWillEnterForeground App在前台 收到通知 触发1 无触发 App在后台 收到通知，什么都不做 无触发 无触发 App在后台 收到通知，点击应用 无触发 触发 App在后台 收到通知，点击通知栏 触发2 触发 App未启动 收到通知，点击通知栏 无触发 无触发 App未启动 收到通知，点击应用 无触发 无触发"},{"title":"AngularJS - 利用ui-route及provider实现页面数据预加载的关键","permalink":"/2016/04/07/angularjs-ui-route-provider/","text":"我在使用angular的时候经常碰到一个问题，希望在必要数据加载完成之前暂时不要显示页面。这时，我一般用ui-route的resolve功能并结合数据接口来实现。（数据api我是一般用provider来封装） 首先，在config中注入testProvider，并非必须，只是演示下如何配置provider。这里有个区别就是，在config中不能直接访问provider的$get中的方法，但是可以访问provider对象的属性与方法。(比如下面代码中的this.setPrefix方法) 其次，然后回到我的需求部分，在ui-route里面获取需要预先加载的数据。这个跟controller中的注入没有区别，如例子只要在resolve.userInfo的方法参数上添加自己需要的provider名称，这里就是test，这样我们就可以直接调用test.current了。resolve也是一个关键，我们用它来获取数据并注入到controller中。 最后，在controller里面注入我们需要使用的数据，userInfo 123456789101112131415161718192021222324252627282930313233343536373839angular.module(&apos;logging&apos;, []) .provider(&quot;test&quot;, function() &#123; var prefix; this.setPrefix = function(p) &#123; prefix = p; &#125; this.$get = function() &#123; return &#123; log: function(msg) &#123; console.log(prefix,msg); &#125;, current:function()&#123; return &#123;&quot;name&quot;:&quot;JMZ&quot;&#125;; &#125; &#125; &#125; &#125;)angular.module(&apos;myApp&apos;, [&apos;logging&apos;]).config([&quot;$stateProvider&quot;, &quot;testProvider&quot; function ($stateProvider, testProvider) &#123; testProvider.setPrefix(&quot;works: &quot;); $stateProvider.state(&quot;home/index&quot;, &#123; url: &quot;/&quot;, &quot;templateUrl&quot;: &quot;home/index.tpl.html&quot;, &quot;controller&quot;: &quot;home/index.ctrl&quot; resolve: &#123; userInfo: function ($q,test) &#123; return test.current(); &#125; &#125; &#125;);&#125;]).controller(&quot;myCtrl&quot;, [&quot;$scope&quot;,&quot;test&quot;,&quot;userInfo&quot;,function($scope, test,userInfo) &#123; test.log(userInfo); $scope.$watch(&apos;myModel&apos;, function(newval) &#123; test.log(newval); &#125;]);&#125;);"},{"title":"gulp-guide","permalink":"/2016/04/07/gulp-guide/","text":"gulpgulp是基于Node.js的前端自动化构建工具，主要用于代码打包。目前主流的前端打包工具，grunt，gulp，webpack。grunt现在似乎慢慢被gulp取代，而我使用gulp也是冲着大家说的配置简单去的，至于通道流，运行文件什么的其实还是次要的；webpack现在很火，听说功能强大，没有用过。 npm install gulp -g 注意需要在npm全局中安装gulp，否则命令窗口中找不到gulp快捷命令，记得检查环境变量的配置情况。 gulp 插件gulp的使用离不开gulp插件的使用，下面是常用的几款。 npm install del gulp gulp-concat gulp-minify-css gulp-replace gulp-uglify gulp-rev gulp-rev-collector –save-devdel 和 gulp-cleandel是node.js的插件，两者的效果相似，都是用来清除文件。至于为什么使用 del，而不是 gulp-clean，我是看到网上一篇文章推荐的。 gulp-concat gulp-concat用来做文件合并，可以将多个文件合并成一个文件，减少静态资源数量。 gulp-minify-css gulp-minify-css是css的压缩工具。 gulp-uglify gulp-uglify是js的压缩工具。官方文档上是这么写的 “Minify files with UglifyJS.” gulp-replace gulp-replace是一个文本修改插件，我们一般用来做文件内容的的修改，常用的是路径修改。 gulp-rev和gulp-rev-collector gulp-rev和gulp-rev-collector，并没有用到，这里只做标示。这两个插件可以用来处理文件名，同时生成一个json文件保存修改前的文件名和修改后的文件名，并且自动处理文件中的修改，例如图片文件至于css文件。 gulp的配置文件gulpfile.jsgulp依赖于配置文件gulpfile.js，在运行目录下需要手动创建gulpfile.js，gulp的任务执行代码会调用gulpfile.js。 gulp 语法gulp的语法很简单，功能实现依赖于各种插件，所以学习上成本很低。gulp的语法其实就是是nodejs的语法。 配置gulpfile1234567891011121314//声明依赖的插件var gulp = require('gulp');var minifycss = require('gulp-minify-css');var concat = require('gulp-concat');var uglify = require('gulp-uglify');var del = require('del');var replace = require('gulp-replace');//定义taskgulp.task('taskName', function() &#123;&#125;);//default是默认task，当命令行缺省调用时会执行default任务。gulp.task('default', []) 命令行调用task1234#直接调用具体的taskgulp taskName #调用默认的default，如果没用会报错gulp 例子12345678910111213141516171819202122232425262728293031323334//多个任务合并gulp.task('default', ['task1', 'task2', 'task3', 'task4']);//文件拷贝语法gulp.src(\"oldPath/images/*.*\") .pipe(gulp.dest(newPath+'/images')); //文件合并且压缩语法//css文件gulp.src(['app/assets/styles/style.css', 'app/assets/styles/public.css', 'app/assets/styles/page.css', 'app/assets/styles/jquery-ui-1.10.3.css']) .pipe(concat('style.css')) .pipe(minifycss()) .pipe(gulp.dest(newPath));//js文件gulp.src([ 'app/components/*/*.js' ]) .pipe(concat('components.js')) .pipe(uglify()) .pipe(gulp.dest(newPath));//文本修改gulp.task('demo-replace', function()&#123; gulp.src(demoDir+'/index.html') .pipe(replace('&lt;link rel=\"stylesheet\"&gt;', '')) //删除 .pipe(replace(/\\.\\.\\/assets\\//g, '')) //正则替换 .pipe(replace(/\\.\\.\\/images/g, 'images')) .pipe(gulp.dest(newPath));//目录清理gulp.task('clean', function(cb)&#123; del(rootPath, cb);&#125;); 作者：http://my.oschina.net/u/924762/blog/628510?fromerr=0sUJ8B33"},{"title":"hexo教程1 - 写作","permalink":"/2016/04/07/hexo-guide-1/","text":"你可以执行下列命令来创建一篇新文章。 1$ hexo new [layout] &lt;title&gt; 您可以在命令中指定文章的布局（layout），默认为 post，可以通过修改 _config.yml 中的 default_layout 参数来指定默认布局。 布局（Layout）Hexo 有三种默认布局：post、page 和 draft，它们分别对应不同的路径，而您自定义的其他布局和 post 相同，都将储存到 source/_posts 文件夹。 布局 路径 post source/_posts page source draft source/_drafts 文件名称Hexo 默认以标题做为文件名称，但您可编辑 new_post_name 参数来改变默认的文件名称，举例来说，设为 :year-:month-:day-:title.md 可让您更方便的通过日期来管理文章。 变量 描述 :title 标题（小写，空格将会被替换为短杠） :year 建立的年份，比如， 2015 :month 建立的月份（有前导零），比如， 04 :i_month 建立的月份（无前导零），比如， 4 :day 建立的日期（有前导零），比如， 07 :i_day 建立的日期（无前导零），比如， 7"},{"title":"Hexo+Github来搭建一个博客站点","permalink":"/2016/04/07/hexo-github/","text":"笔记 简单的记录利用hexo来搭建一个github.io的博客站点 hexo什么是hexo？Hexo是一个快速、简洁且搞笑的博客框架。Hexo使用Markdown（也可使用其他渲染引擎）来解析文章，在几秒内即可通过配置好的主题来生成静态网页。 安装首先前提条件，你需要在电脑内安装好下列软件：（此部分省略） Node.js Git 然后，我们用npm执行下面命令就可以完成hexo的安装： 1npm install -g hexo-cli Hexo简要命令 1234hexo n #生成文章，或者也可以在source/_posts手动编辑hexo s #本地预览hexo g #生成public静态网站#生成public目录之后，可以利用git来手动同步到github.io上 Github.io注册 登录github并注册自己的帐号，例name 创建一个新的repository，名称必须是跟帐号名称一致，例name.github.io 首次创建需要耐心等待，之后就可以访问静态主页，输入http://name.github.io 同步内容至Github建议不要直接在hexo的public下面追加git版本管理，这里只做为参考 进到hexo生成的public目录并执行git init命令 追加远程gitgit remote add xxxooo 然后提交修改并push到github上面 再次输入http://name.github.io你应该可以看到最新的页面了。 自动Deploy想要自动发布到Github.io上面的话，我们需要用到hexo-deployer-git这个功能组件。首先，还是利用npm install xxx来安装，也可以在package.json里面配置好。 然后找到_config.yml里面的deploy项，在这个配置项下面追加两个属性值type和repo，如下所示： 123deploy: type: git repo: git@github.com:jmz331/jmz331.github.io.git 然后就是配置好本地提交github的权限，具体设置参考 如何配置github"}]}