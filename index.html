<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  




<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="ChinaJMZ" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="欢迎来到ChinaJMZ的小站">
<meta property="og:url" content="/index.html">
<meta property="og:site_name" content="欢迎来到ChinaJMZ的小站">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="欢迎来到ChinaJMZ的小站">
<meta name="twitter:description">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> 欢迎来到ChinaJMZ的小站 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">欢迎来到ChinaJMZ的小站</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-th fa-fw"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags fa-fw"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-user fa-fw"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/09/Java-中的变长参数/" itemprop="url">
                  Java 中的变长参数
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-03-09T12:06:14+09:00" content="2017-03-09">
              2017-03-09
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/后端开发/" itemprop="url" rel="index">
                    <span itemprop="name">后端开发</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/03/09/Java-中的变长参数/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/03/09/Java-中的变长参数/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在 Java 5 中提供了变长参数，允许在调用方法时传入不定长度的参数。变长参数是Java的一个语法糖，本质上还是基于数组的实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void foo(String... args);</span><br><span class="line">void foo(String[] args);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//方法签名</span><br><span class="line">([Ljava/lang/String;)V // public void foo(String[] args)</span><br></pre></td></tr></table></figure>
<p>从方法的签名可以看到，变长参数在编译为字节码后，在方法签名中就是以数组形态出现的。这两个方法的签名是一致的，不能作为方法的重载。如果同时出现，是不能编译通过的。可变参数可以兼容数组，反之则不成立。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void foo(String...varargs)&#123;&#125;</span><br><span class="line"></span><br><span class="line">foo(&quot;arg1&quot;, &quot;arg2&quot;, &quot;arg3&quot;);</span><br><span class="line"></span><br><span class="line">//上述过程和下面的调用是等价的</span><br><span class="line">foo(new String[]&#123;&quot;arg1&quot;, &quot;arg2&quot;, &quot;arg3&quot;&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="使用规则"><a href="#使用规则" class="headerlink" title="使用规则"></a>使用规则</h2><h3 id="优先匹配固定参数"><a href="#优先匹配固定参数" class="headerlink" title="优先匹配固定参数"></a>优先匹配固定参数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void foo(String arg1, String arg2) &#123;</span><br><span class="line">    System.out.println(&quot;invoke first method!&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void foo(String... args) &#123;</span><br><span class="line">    System.out.println(&quot;invoke second method!&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(&quot;arg1&quot;, &quot;arg2&quot;); //invoke first method!</span><br><span class="line">foo(&quot;arg1&quot;, &quot;arg2&quot;, &quot;arg3&quot;); //invoke second method!</span><br></pre></td></tr></table></figure>
<h3 id="如果同时匹配多个可变参数，无法编译通过"><a href="#如果同时匹配多个可变参数，无法编译通过" class="headerlink" title="如果同时匹配多个可变参数，无法编译通过"></a>如果同时匹配多个可变参数，无法编译通过</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void foo(String arg1, String... args) &#123;</span><br><span class="line">    System.out.println(&quot;invoke first method!&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void foo(String... args) &#123;</span><br><span class="line">    System.out.println(&quot;invoke second method!&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(&quot;arg1&quot;);//compile error</span><br></pre></td></tr></table></figure>
<p>可变参数只能有一个，且必须在参数列表最后</p>
<h2 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h2><p>在使用变长参数时，有必要遵循一些规范，使得别人更容易理解你的代码。以下三个建议来自「编写高质量代码：改善Java程序的151个建议」一书。</p>
<h3 id="避免带有变长参数的方法重载"><a href="#避免带有变长参数的方法重载" class="headerlink" title="避免带有变长参数的方法重载"></a>避免带有变长参数的方法重载</h3><p>即便编译器可以按照优先匹配固定参数的方式确定具体的调用方法，但在阅读代码的依然容易掉入陷阱。要慎重考虑变长参数的方法重载。</p>
<h3 id="别让null值和空值威胁到变长方法"><a href="#别让null值和空值威胁到变长方法" class="headerlink" title="别让null值和空值威胁到变长方法"></a>别让null值和空值威胁到变长方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Client &#123;  </span><br><span class="line">     public void methodA(String str,Integer... is)&#123;       </span><br><span class="line">     &#125;  </span><br><span class="line"></span><br><span class="line">     public void methodA(String str,String... strs)&#123;          </span><br><span class="line">     &#125;  </span><br><span class="line"></span><br><span class="line">     public static void main(String[] args) &#123;  </span><br><span class="line">           Client client = new Client();  </span><br><span class="line">           client.methodA(&quot;China&quot;, 0);  </span><br><span class="line">           client.methodA(&quot;China&quot;, &quot;People&quot;);  </span><br><span class="line">           client.methodA(&quot;China&quot;);  //compile error</span><br><span class="line">           client.methodA(&quot;China&quot;,null);  //compile error</span><br><span class="line">     &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;  </span><br><span class="line">     Client client = new Client();  </span><br><span class="line">     String[] strs = null;  </span><br><span class="line">     client.methodA(&quot;China&quot;,strs);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>让编译器知道这个null值是String类型的，编译即可顺利通过，也就减少了错误的发生。</p>
<h3 id="覆写变长方法也要循规蹈矩"><a href="#覆写变长方法也要循规蹈矩" class="headerlink" title="覆写变长方法也要循规蹈矩"></a>覆写变长方法也要循规蹈矩</h3><p>在子类中覆写父类的方法，需要满足以下几个条件：</p>
<p>覆写方法不能缩小访问权限。<br>参数列表必须与被覆写方法相同。<br>返回类型必须与被覆写方法的相同或是其子类。<br>覆写方法不能抛出新的异常，或者超出父类范围的异常，但是可以抛出更少、更有限的异常，或者不抛出异常。<br>我们看一下下面的这个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class Client &#123;  </span><br><span class="line">     public static void main(String[] args) &#123;  </span><br><span class="line">        //向上转型  </span><br><span class="line">        Base  base = new Sub();  </span><br><span class="line">        base.fun(100, 50);  </span><br><span class="line">        //不转型  </span><br><span class="line">        Sub sub = new Sub();  </span><br><span class="line">        sub.fun(100, 50);  //compile error</span><br><span class="line">     &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">//基类  </span><br><span class="line">class Base&#123;  </span><br><span class="line">    void fun(int price, int... discounts)&#123;  </span><br><span class="line">        System.out.println(&quot;Base......fun&quot;);  </span><br><span class="line">    &#125;     </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">//子类，覆写父类方法  </span><br><span class="line">class Sub extends Base&#123;  </span><br><span class="line">    @Override  </span><br><span class="line">    void fun(int price, int[] discounts)&#123;  </span><br><span class="line">        System.out.println(&quot;Sub......fun&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子类中覆写父类的方法是没有问题的，因为方法的签名是一致的，父类的 fun 方法中 int… 参数在编译成字节码后是 int[]， 子类在参数列表中直接使用 int[] 是一致的。然而在编译时 main 方法中第二个调用却会出错。</p>
<p>这太奇怪了：子类继承了父类的所有属性和方法，甭管是私有的还是公开的访问权限，同样的参数、同样的方法名，通过父类调用没有任何问题，通过子类调用却编译通不过，为啥？难道是没继承下来？或者子类缩小了父类方法的前置条件？那如果是这样，就不应该覆写，@Override就应该报错，真是奇妙的事情！</p>
<p>事实上，base对象是把子类对象Sub做了向上转型，形参列表是由父类决定的，由于是变长参数，在编译时，“base.fun(100, 50)”中的“50”这个实参会被编译器“猜测”而编译成“{50}”数组，再由子类Sub执行。我们再来看看直接调用子类的情况，这时编译器并不会把“50”做类型转换，因为数组本身也是一个对象，编译器还没有聪明到要在两个没有继承关系的类之间做转换，要知道Java是要求严格的类型匹配的，类型不匹配编译器自然就会拒绝执行，并给予错误提示。</p>
<p>这是个特例，覆写的方法参数列表与父类不完全相同，这违背了覆写的定义，并且会引发莫名其妙的错误。所以在对变长参数进行覆写时，如果要使用此类似的方法，请仔细想想是不是一定要如此。在进行方法覆写的时候，方法参数要与父类完全一致，不仅仅是类型、数量，还包括显示形式。</p>
<h2 id="可能会踩的坑"><a href="#可能会踩的坑" class="headerlink" title="可能会踩的坑"></a>可能会踩的坑</h2><h3 id="使用-Object…-作为变长参数"><a href="#使用-Object…-作为变长参数" class="headerlink" title="使用 Object… 作为变长参数"></a>使用 Object… 作为变长参数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public void foo(Object... args) &#123;</span><br><span class="line">    System.out.println(args.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(new String[]&#123;&quot;arg1&quot;, &quot;arg2&quot;, &quot;arg3&quot;&#125;); //3</span><br><span class="line">foo(100, new String[]&#123;&quot;arg1&quot;, &quot;arg1&quot;&#125;); //2</span><br><span class="line"></span><br><span class="line">foo(new Integer[]&#123;1, 2, 3&#125;); //3</span><br><span class="line">foo(100, new Integer[]&#123;1, 2, 3&#125;); //2</span><br><span class="line">foo(1, 2, 3); //3</span><br><span class="line">foo(new int[]&#123;1, 2, 3&#125;); //1</span><br></pre></td></tr></table></figure>
<p>int[] 无法转型为 Object[], 因而被当作一个单纯的数组对象 ; Integer[] 可以转型为 Object[], 可以作为一个对象数组。</p>
<h3 id="反射方法调用时的注意事项"><a href="#反射方法调用时的注意事项" class="headerlink" title="反射方法调用时的注意事项"></a>反射方法调用时的注意事项</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void foo(String... varargs)&#123;</span><br><span class="line">        System.out.println(args.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        String[] varArgs = new String[]&#123;&quot;arg1&quot;, &quot;arg2&quot;&#125;;</span><br><span class="line">        try&#123;</span><br><span class="line">            Method method = Test.class.getMethod(&quot;foo&quot;, String[].class);</span><br><span class="line">            method.invoke(null, varArgs);</span><br><span class="line">            method.invoke(null, (Object[])varArgs);</span><br><span class="line">            method.invoke(null, (Object)varArgs);</span><br><span class="line">            method.invoke(null, new Object[]&#123;varArgs&#125;);</span><br><span class="line">        &#125; catch (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的四个调用中，前两个都会在运行时抛出<code>java.lang.IllegalArgumentException: wrong number of arguments</code>异常，后两个则正常调用。</p>
<p>反射是运行时获取的，在运行时看来，可变长参数和数组是一致的，因而方法签名为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//方法签名</span><br><span class="line">([Ljava/lang/String;)V // public void foo(String[] varargs)</span><br></pre></td></tr></table></figure>
<p>再来看一下 Method 对象的方法声明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object invoke(Object obj, Object... args)</span><br></pre></td></tr></table></figure>
<p>args 虽然是一个可变长度的参数，但是 args 的长度是受限于该方法对象代表的真实方法的参数列表长度的，而从运行时签名来看，<code>([Ljava/lang/String;)V</code>实际上只有一个形参，即<code>String[] varargs</code>，因而<code>invoke(Object obj, Object... args)</code>中可变参数 args 的实参长度只能为1。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//Object invoke(Object obj, Object... args)</span><br><span class="line">//String[] varArgs = new String[]&#123;&quot;arg1&quot;, &quot;arg2&quot;&#125;;</span><br><span class="line">method.invoke(null, varArgs); //varArgs长度为2，错误</span><br><span class="line">method.invoke(null, (Object[])varArgs); //将String[]转换为Object[],长度为2的，错误</span><br><span class="line">method.invoke(null, (Object)varArgs);//将整个String[] 转为Object，长度为1，符合</span><br><span class="line">method.invoke(null, new Object[]&#123;varArgs&#125;);//Object[]长度为1，正确。上一个和这个是等价的</span><br></pre></td></tr></table></figure>
<h2 id="什么时候使用可变长参数？"><a href="#什么时候使用可变长参数？" class="headerlink" title="什么时候使用可变长参数？"></a>什么时候使用可变长参数？</h2><p>Stack Overflow上有个关于变长参数使用的问题。简单地说，<br>在不确定方法需要处理的对象的数量时可以使用可变长参数，会使得方法调用更简单，无需手动创建数组 new T[]{…} 。</p>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/01/05/Vagrant使用说明1/" itemprop="url">
                  Vagrant使用说明1
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-01-05T10:35:50+09:00" content="2017-01-05">
              2017-01-05
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/01/05/Vagrant使用说明1/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/01/05/Vagrant使用说明1/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <pre><code>Create and configure lightweight, reproducible, and portable development environments.
</code></pre><p>正如官网所描述的一样Vagrant是一个类似于docker能用来快速的配置锁需要的开发环境，而不收到每台机子自身环境的影响。</p>
<h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><p>Vagrant有下列基本使用命令来控制管理虚拟机：</p>
<p>执行方式： vagrant <command></p>
<ul>
<li>up 启动虚拟机</li>
<li>halt 关闭虚拟机</li>
<li>suspend 暂停虚拟机，虚拟机内存等信息将以文件的方式保存在本地，可以通过执行恢复操作来继续使用</li>
<li>resume 恢复虚拟机，与前面的暂停相对应</li>
<li>destroy 删除虚拟机，会删除当前虚拟机，但是Vagrantfile文件会被保留</li>
</ul>
<h4 id="实际使用"><a href="#实际使用" class="headerlink" title="实际使用"></a>实际使用</h4><p>1.下载并添加box</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#将指定位置（./precise32.box）的box以`“precise32”`的名字添加到本地box中</span><br><span class="line">vagrant box add precise32 ./precise32.box</span><br><span class="line">#查看本地box列表</span><br><span class="line">vagrant box list</span><br></pre></td></tr></table></figure>
<p>2.创建一个虚拟机</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir ~/temp/test</span><br><span class="line">cd ~/temp/test</span><br><span class="line">vagrant init</span><br></pre></td></tr></table></figure>
<p>执行以上命令后，会在temp/test目录下自动生成一个Vagrantfile文件，下面的例子是创建一个名为web1的私有网络服务器192.168.50.4（只能被本机访问）</p>
<p>Vagrantfile</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">VAGRANTFILE_API_VERSION = &quot;2&quot;</span><br><span class="line"></span><br><span class="line">Vagrant.configure(VAGRANTFILE_API_VERSION) do |config|</span><br><span class="line">  </span><br><span class="line">config.vm.define &quot;web1&quot; do |web1|</span><br><span class="line">    web1.vm.box = &quot;precise32&quot;</span><br><span class="line">    web1.vm.network &quot;private_network&quot;, ip: &quot;192.168.50.4&quot;</span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>然后在当前目录下启动服务器并通过ssh登录到虚拟机内</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vagrant up</span><br><span class="line">vagrant ssh</span><br></pre></td></tr></table></figure>
<p>3.打包已配置的环境</p>
<p>当然，我们的最终目的是团队间共享同一个开发环境，那么我们就必须要用到打包功能。Vagrant提供了一个很简单的命令，来打包我们配置号的开发环境。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#首先，还是进入到虚拟机目录，然后执行下面命令</span><br><span class="line">#我们将当前目录打包成一个web.box文件</span><br><span class="line">vagrant package --output web.box</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/04/11/lodash-使用笔记/" itemprop="url">
                  lodash - 使用笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-04-11T17:04:23+09:00" content="2016-04-11">
              2016-04-11
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/前端开发/" itemprop="url" rel="index">
                    <span itemprop="name">前端开发</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/04/11/lodash-使用笔记/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/04/11/lodash-使用笔记/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="transform（转换）"><a href="#transform（转换）" class="headerlink" title="transform（转换）"></a>transform（转换）</h2><p>官方API说明</p>
<p><code>_.transform(object, [iteratee=_.identity], [accumulator])</code></p>
<p><strong>Arguments</strong></p>
<ul>
<li>object (Array|Object): The object to iterate over.</li>
<li>[iteratee=_.identity] (Function): The function invoked per iteration.</li>
<li>[accumulator] (*): The custom accumulator value.</li>
</ul>
<p><strong>Returns</strong></p>
<p>(*): Returns the accumulated value.</p>
<p>例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//筛选所有2的倍数</span></span><br><span class="line">_.transform([<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>], <span class="function"><span class="keyword">function</span>(<span class="params">result, n</span>) </span>&#123;</span><br><span class="line">  n % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; result.push(n);</span><br><span class="line">&#125;, []);</span><br><span class="line"><span class="comment">// → [2, 4, 6]</span></span><br><span class="line"><span class="comment">//筛选2个2的倍数</span></span><br><span class="line">_.transform([<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>], <span class="function"><span class="keyword">function</span>(<span class="params">result, n</span>) </span>&#123;</span><br><span class="line">  n % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; result.push(n);</span><br><span class="line">  <span class="comment">//结束循环</span></span><br><span class="line">  <span class="keyword">if</span>(result.length == <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;, []);</span><br><span class="line"><span class="comment">// → [2, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//反转Key跟Value</span></span><br><span class="line">_.transform(&#123; <span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>: <span class="number">2</span>, <span class="string">'c'</span>: <span class="number">1</span> &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">result, value, key</span>) </span>&#123;</span><br><span class="line">  (result[value] || (result[value] = [])).push(key);</span><br><span class="line">&#125;, &#123;&#125;);</span><br><span class="line"><span class="comment">// → &#123; '1': ['a', 'c'], '2': ['b'] &#125;</span></span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/04/11/EMCAScript6：下一版本的JavaScript的新特性/" itemprop="url">
                  EMCAScript6：下一版本的JavaScript的新特性
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-04-11T14:18:13+09:00" content="2016-04-11">
              2016-04-11
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/前端开发/" itemprop="url" rel="index">
                    <span itemprop="name">前端开发</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/04/11/EMCAScript6：下一版本的JavaScript的新特性/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/04/11/EMCAScript6：下一版本的JavaScript的新特性/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>你可能已经听说过EMCAScript6（ES6）了，这是下一个版本的Javascript，它包含了一些很棒的新特性。这些特性拥有不同程度的复杂性，对于简单的脚本和复杂的应用程序都非常的有用。本文将盘点一些ES6的新特性，这些特性都可以用在你日常的编码中。</p>
<p>请注意，只有现代浏览器才能支持这些新的ES6特性，虽然浏览器的支持各不相同。如果你需要兼容那些不支持ES6新特性的旧浏览器，我也会谈谈关于这方面的解决方案。</p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="LET"><a href="#LET" class="headerlink" title="LET"></a>LET</h3><p>通常我们使用var关键字来声明变量，现在我们同样可以使用let，它们之间的细微差别在于作用域。使用var声明变量时，该变量的作用域是其最近的函数，而使用let声明变量，它的作用域只在包含它的块。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if(true) &#123;</span><br><span class="line">   let x = 1;</span><br><span class="line">&#125;</span><br><span class="line">console.log(x); // undefined</span><br></pre></td></tr></table></figure>
<p>这样可以让代码更加干净整洁，可以减少无用的变量。</p>
<p>看看下面这个经典的数组循环：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for(let i = 0, l = list.length; i &lt; l; i++) &#123;</span><br><span class="line">   // do something with list[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(i); // undefined</span><br></pre></td></tr></table></figure>
<p>举个例子，经常会有人使用变量j在同一作用域中的另外一个循环中。但是使用let声明变量，你可以很安全地再声明一次，因为它只在自己块级作用域内定义和有效。</p>
<h3 id="CONST"><a href="#CONST" class="headerlink" title="CONST"></a>CONST</h3><p>声明块级作用域内的变量的另一种方法是使用const。使用const，你可以声明一个只读的值，必须直接指定一个值，如果尝试改变它的值或者没有立即指定一个值，就会得到下面的错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const MY_CONSTANT = 1;</span><br><span class="line">MY_CONSTANT = 2 // Error</span><br><span class="line">const SOME_CONST; // Error</span><br></pre></td></tr></table></figure>
<p>注意，你还是可以修改对象的属性或者数组的成员</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const MY_OBJECT = &#123;some: 1&#125;;</span><br><span class="line">MY_OBJECT.some = &apos;body&apos;; // Cool</span><br></pre></td></tr></table></figure>
<h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>箭头函数对于Javascript来说是一个非常棒的补充，它可以让代码更加精简。我们首先来介绍箭头函数，在稍后的其他例子中就会使用到它的优点。下面的代码展示了一个箭头函数和我们熟悉的ES5风格的两种写法的函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let books = [&#123;title: &apos;X&apos;, price: 10&#125;, &#123;title: &apos;Y&apos;, price: 15&#125;];</span><br><span class="line"></span><br><span class="line">let titles = books.map( item =&gt; item.title );</span><br><span class="line"></span><br><span class="line">// ES5 equivalent:</span><br><span class="line">var titles = books.map(function(item) &#123;</span><br><span class="line">   return item.title;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>我们来看看箭头函数的语法，其中没有function关键字，剩下的就是0个或多个参数、(=&gt;)箭头和函数表达式。注意：return语句将隐式地被添加进来。</p>
<p>如果是0个或多个参数，必须添加括号：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// No arguments</span><br><span class="line">books.map( () =&gt; 1 ); // [1, 1]</span><br><span class="line"></span><br><span class="line">// Multiple arguments</span><br><span class="line">[1,2].map( (n, index) =&gt; n * index ); // [0, 2]</span><br></pre></td></tr></table></figure>
<p>如果需要更多的逻辑或者空白区域，可以将函数表达式放在({…})块中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let result = [1, 2, 3, 4, 5].map( n =&gt; &#123;</span><br><span class="line">   n = n % 3;</span><br><span class="line">   return n;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>箭头函数不仅仅意味着更少的字符，它的行为也不同于常规的函数。一个箭头函数从它的外界上下文中继承this和arguments关键字。这表示你可以摆脱以前那些难看的语句，比如var that = this，而且不需要绑定函数到正确的上下文中。下面有一个例子（注意：this.title等同于ES5版本的that.title）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">let book = &#123;</span><br><span class="line">   title: &apos;X&apos;,</span><br><span class="line">   sellers: [&apos;A&apos;, &apos;B&apos;],</span><br><span class="line">   printSellers() &#123;</span><br><span class="line">      this.sellers.forEach(seller =&gt; console.log(seller + &apos; sells &apos; + this.title));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ES5 equivalent:</span><br><span class="line">var book = &#123;</span><br><span class="line">   title: &apos;X&apos;,</span><br><span class="line">   sellers: [&apos;A&apos;, &apos;B&apos;],</span><br><span class="line">   printSellers: function() &#123;</span><br><span class="line">      var that = this;</span><br><span class="line">      this.sellers.forEach(function(seller) &#123;</span><br><span class="line">         console.log(seller + &apos; sells &apos; + that.title)</span><br><span class="line">      &#125;)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>String的prototype中添加了几个方便的方法，大部分是indexOf方法的变通：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&apos;my string&apos;.startsWith(&apos;my&apos;); //true</span><br><span class="line">&apos;my string&apos;.endsWith(&apos;my&apos;); // false</span><br><span class="line">&apos;my string&apos;.includes(&apos;str&apos;); // true</span><br></pre></td></tr></table></figure>
<p>简单有效！另外，还添加了一个方便创建重复字符串的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;my &apos;.repeat(3); // &apos;my my my &apos;</span><br></pre></td></tr></table></figure>
<h3 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h3><p>模板字符串提供了一个简洁的方式去创建字符串和实现字符串插值。你可能已经熟悉了它的语法，模板字符串基于美元符号和花括号${…}，并且要使用反引号(`)将其包围。</p>
<p>下面是一个简单的演示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let name = &apos;John&apos;,</span><br><span class="line">   apples = 5,</span><br><span class="line">   pears = 7,</span><br><span class="line">   bananas = function() &#123; return 3; &#125;</span><br><span class="line"></span><br><span class="line">console.log(`This is $&#123;name&#125;.`);</span><br><span class="line"></span><br><span class="line">console.log(`He carries $&#123;apples&#125; apples, $&#123;pears&#125; pears, and $&#123;bananas()&#125; bananas.`);</span><br><span class="line"></span><br><span class="line">// ES5 equivalent:</span><br><span class="line">console.log(&apos;He carries &apos; + apples + &apos; apples, &apos; + pears + &apos; pears, and &apos; + bananas() +&apos; bananas.&apos;);</span><br></pre></td></tr></table></figure>
<p>上面的示例中，和ES5相比较，模板字符串仅仅只是方便字符串的串联。模板字符串通常应用于多行字符串，请记住，空白是字符串的一部分。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let x = `1...</span><br><span class="line">2...</span><br><span class="line">3 lines long!`; // Yay</span><br><span class="line"></span><br><span class="line">// ES5 equivalents:</span><br><span class="line">var x = &quot;1...\n&quot; + </span><br><span class="line">&quot;2...\n&quot; +</span><br><span class="line">&quot;3 lines long!&quot;;</span><br><span class="line"></span><br><span class="line">var x = &quot;1...\n2...\n3 lines long!&quot;;</span><br></pre></td></tr></table></figure>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>Array对象现在新增了一些静态方法以及prototype上的一些方法。</p>
<p>第一、Array.from方法从类数组或可迭代对象上创建Array的实例。类数组对象的例子包括：</p>
<ol>
<li>函数中的arguments对象</li>
<li>document.getElementsByTagName放回的一个nodeList对象</li>
<li>新的Map和Set数据结构</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let itemElements = document.querySelectorAll(&apos;.items&apos;);</span><br><span class="line">let items = Array.from(itemElements);</span><br><span class="line">items.forEach(function(element) &#123;</span><br><span class="line">    console.log(element.nodeType)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// A workaround often used in ES5:</span><br><span class="line">let items = Array.prototype.slice.call(itemElements);</span><br></pre></td></tr></table></figure>
<p>上面的示例中，可以看出items数组拥有forEach方法，但是在itemElements集合中，这个方法是不可用的。</p>
<p>Array.from有一个有趣的特性是它的第二个可选参数mapFunction，这个参数允许在单次调用中创建一个新的映射数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let navElements = document.querySelectorAll(&apos;nav li&apos;);</span><br><span class="line">let navTitles = Array.from(navElements, el =&gt; el.textContent);</span><br></pre></td></tr></table></figure>
<p>第二、Array.of方法，这个方法的行为有点像Array的构造函数，它修复了传递单个数字参数时的特殊情况，所以Array.of相比于new Array()更好。不过大多数情况下，我们推荐使用数组字面量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let x = new Array(3); // [undefined, undefined, undefined]</span><br><span class="line">let y = Array.of(8); // [8]</span><br><span class="line">let z = [1, 2, 3]; // Array literal</span><br></pre></td></tr></table></figure>
<p>最后，Array的prototype中添加了几个方法，其中的find方法我觉得Javascript开发者将会非常喜欢。</p>
<ol>
<li>find方法：获取回调函数return true的第一个元素。</li>
<li>findIndex方法：获取回调函数return true的第一个元素的索引</li>
<li>fill方法：根据给定的参数重写数组的元素</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[5, 1, 10, 8].find(n =&gt; n === 10) // 10</span><br><span class="line"></span><br><span class="line">[5, 1, 10, 8].findIndex(n =&gt; n === 10) // 2</span><br><span class="line"></span><br><span class="line">[0, 0, 0].fill(7) // [7, 7, 7]</span><br><span class="line">[0, 0, 0, 0, 0].fill(7, 1, 3) // [0, 7, 7, 7, 0]</span><br></pre></td></tr></table></figure>
<h2 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h2><p>Math对象也添加了几个方法。</p>
<ol>
<li>Math.sign 返回一个数字的符号，有1，-1或0三个值分别表示正值，负值或0</li>
<li>Math.trunc 返回一个数字去掉小数位数后的数</li>
<li>Math.cbrt 返回一个数字的立方根</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Math.sign(5); // 1</span><br><span class="line">Math.sign(-9); // -1</span><br><span class="line"></span><br><span class="line">Math.trunc(5.9); // 5</span><br><span class="line">Math.trunc(5.123); // 5</span><br><span class="line"></span><br><span class="line">Math.cbrt(64); // 4</span><br></pre></td></tr></table></figure>
<p>如果你想要学习更多的新的Math内容，点击new number and math features in ES6。</p>
<h2 id="扩展操作符"><a href="#扩展操作符" class="headerlink" title="扩展操作符"></a>扩展操作符</h2><p>扩展操作符(…)是一个非常方便的语法，它用于在数组的特殊的地方扩展元素，比如函数调用中的参数。下面展示一些例子来说明它的用处。</p>
<p>首先，我们来看看如何通过另一个数组来扩展数组的元素：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let values = [1, 2, 4];</span><br><span class="line">let some = [...values, 8]; // [1, 2, 4, 8]</span><br><span class="line">let more = [...values, 8, ...values]; // [1, 2, 4, 8, 1, 2, 4]</span><br><span class="line"></span><br><span class="line">// ES5 equivalent:</span><br><span class="line">let values = [1, 2, 4];</span><br><span class="line">// Iterate, push, sweat, repeat...</span><br><span class="line">// Iterate, push, sweat, repeat...</span><br></pre></td></tr></table></figure>
<p>当使用参数调用函数时，扩展操作符同样非常强大。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let values = [1, 2, 4];</span><br><span class="line"></span><br><span class="line">doSomething(...values);</span><br><span class="line"></span><br><span class="line">function doSomething(x, y, z) &#123;</span><br><span class="line">   // x = 1, y = 2, z = 4</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ES5 equivalent:</span><br><span class="line">doSomething.apply(null, values);</span><br></pre></td></tr></table></figure>
<p>正如你所看到的，这避免了我们经常使用的fn.apply()这种委婉曲折的方式。扩展操作符语法非常灵活，因为它可以在参数列表的任何地方使用，即下面的调用方式也会产生一样的结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let values = [2, 4];</span><br><span class="line">doSomething(1, ...values);</span><br></pre></td></tr></table></figure>
<p>我们已经将扩展操作符应用到Array和arguents中了。实际上，所有的可迭代的对象都可以应用扩展操作符，比如NodeList：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let form = document.querySelector(&apos;#my-form&apos;),</span><br><span class="line">   inputs = form.querySelectorAll(&apos;input&apos;),</span><br><span class="line">   selects = form.querySelectorAll(&apos;select&apos;);</span><br><span class="line"></span><br><span class="line">let allTheThings = [form, ...inputs, ...selects];</span><br></pre></td></tr></table></figure>
<p>现在allTheThings变成一个扁平的数组，其中包含form节点，input和select的子节点。</p>
<h2 id="解构"><a href="#解构" class="headerlink" title="解构"></a>解构</h2><p>解构提供了一个便捷的方式来从对象或数组中提取数据。下面给了一个使用数组的典型例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let [x, y] = [1, 2]; // x = 1, y = 2</span><br><span class="line"></span><br><span class="line">// ES5 equivalent:</span><br><span class="line">var arr = [1, 2];</span><br><span class="line">var x = arr[0];</span><br><span class="line">var y = arr[1];</span><br></pre></td></tr></table></figure>
<p>使用这种语法，可以一次性指定多个变量。还有另外一个作用是可以很简单的交换两个变量值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let x = 1,</span><br><span class="line">   y = 2;</span><br><span class="line"></span><br><span class="line">[x, y] = [y, x]; // x = 2, y = 1</span><br></pre></td></tr></table></figure>
<p>解构也能用于对象上，要保证key值匹配。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;x: 1, y: 2&#125;;</span><br><span class="line">let &#123;x, y&#125; = obj; // x = 1, y = 2</span><br></pre></td></tr></table></figure>
<p>也可以通过这个机制来修改变量的名称</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;x: 1, y: 2&#125;;</span><br><span class="line">let &#123;x: a, y: b&#125; = obj; // a = 1, b = 2</span><br></pre></td></tr></table></figure>
<p>还有另外一个有趣的用法是模拟多个返回值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function doSomething() &#123;</span><br><span class="line">   return [1, 2]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let [x, y] = doSomething(); // x = 1, y = 2</span><br></pre></td></tr></table></figure>
<p>解构同样也可以指定argument对象的默认值，通过字面量对象，可以模拟命名参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function doSomething(&#123;y = 1, z = 0&#125;) &#123;</span><br><span class="line">   console.log(y, z);</span><br><span class="line">&#125;</span><br><span class="line">doSomething(&#123;y: 2&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><h3 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h3><p>在ES6中，是可以给函数参数定义一个默认值的，语法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function doSomething(x, y = 2) &#123;</span><br><span class="line">   return x * y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">doSomething(5); // 10</span><br><span class="line">doSomething(5, undefined); // 10</span><br><span class="line">doSomething(5, 3); // 15</span><br></pre></td></tr></table></figure>
<p>这样看起来就简洁多了，如果是ES5之前的写法，我们肯定要补充一些参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function doSomething(x, y) &#123;</span><br><span class="line">   y = y === undefined ? 2 : y;</span><br><span class="line">   return x * y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>undefined或者无参时将会触发参数的默认值。</p>
<h3 id="剩余不定参数"><a href="#剩余不定参数" class="headerlink" title="剩余不定参数"></a>剩余不定参数</h3><p>我们已经看过了扩展操作符，不定参数与其非常相似。不定参数也使用…语法，它允许将函数末端的参数存储在一个数组里面。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function doSomething(x, ...remaining) &#123;</span><br><span class="line">   return x * remaining.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">doSomething(5, 0, 0, 0); // 15</span><br></pre></td></tr></table></figure>
<h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>模块是Javascript中非常受欢迎的一个补充，我认为它是ES6中非常值得挖掘的一个特性。</p>
<p>现如今，任何重要的JS项目都会使用某种模块系统-可能是“暴露型模块模式”或者更广泛的AMD和Common.js。但是，浏览器是没有任何模块系统的特性的，总是需要为AMD或CommonJS模块构建加载模块，处理这些的工具包括RequireJS，Browserify和Webpack。</p>
<p>ES6规范中同时包含了模块中的语法和加载机制。如果你想要在以后使用模块，应该使用下面的语法。现代的构建工具可以通过插件支持这种格式，所以我们可以尽管去使用它。（不用担心，我们在后面的“Transpilation”章节中会讨论这个问题）。</p>
<p>现在，在ES6的模块语法中，模块被设计成使用export和import两个关键字，我们来看看示例中的两个模块。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// lib/math.js</span><br><span class="line"></span><br><span class="line">export function sum(x, y) &#123;</span><br><span class="line">   return x + y;</span><br><span class="line">&#125;</span><br><span class="line">export var pi = 3.141593;</span><br><span class="line">// app.js</span><br><span class="line"></span><br><span class="line">import &#123; sum, pi &#125; from &quot;lib/math&quot;;</span><br><span class="line">console.log(&apos;2π = &apos; + sum(pi, pi));</span><br></pre></td></tr></table></figure>
<p>如你所见，代码中有多个export语句。每一个都必须显式地声明输出的值，在这个例子中，就是function和var。</p>
<p>示例中的import语句使用了一个语法（类似于解构）来显式地定义了输出的内容。要将整个模块一起输出，可以使用通配符“*”，结合as关键字给模块一个本地名称。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// app.js</span><br><span class="line"></span><br><span class="line">import * as math from &quot;lib/math&quot;;</span><br><span class="line">console.log(&apos;2π = &apos; + math.sum(math.pi, math.pi));</span><br></pre></td></tr></table></figure>
<p>模块系统有一个默认模块，它也可以是函数。要导出模块内的默认值，需要提供一个本地名称：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// lib/my-fn.js</span><br><span class="line"></span><br><span class="line">export default function() &#123;</span><br><span class="line">   console.log(&apos;echo echo&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// app.js</span><br><span class="line"></span><br><span class="line">import doSomething from &apos;lib/my-fn&apos;;</span><br><span class="line">doSomething();</span><br></pre></td></tr></table></figure>
<p>注意：import语句是同步的，但是它会等到所有依赖的加载完毕才会执行。</p>
<h2 id="Classes"><a href="#Classes" class="headerlink" title="Classes"></a>Classes</h2><p>类是ES6中讨论得很多的一个特性。一些人类违反了JS的原型性质，而其他人觉得这降低了初学者和来自其他开发语言的开发者的入门门槛，并且能够帮助他们编写大规模应用。无论如何，它都是ES6中的一部分，我们简单地介绍一下。</p>
<p>我们通过class和constructor关键字构建类，下面是一个简短的示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Vehicle &#123;</span><br><span class="line">   constructor(name) &#123;</span><br><span class="line">      this.name = name;</span><br><span class="line">      this.kind = &apos;vehicle&apos;;</span><br><span class="line">   &#125;</span><br><span class="line">   getName() &#123;</span><br><span class="line">      return this.name;</span><br><span class="line">   &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Create an instance</span><br><span class="line">let myVehicle = new Vehicle(&apos;rocky&apos;);</span><br></pre></td></tr></table></figure>
<p>注意：类的定义并不是一个普通的对象，因此类成员之间没有使用逗号来分隔。</p>
<p>从一个类创建实例必须使用new关键字，而从一个基类继承则使用extends：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Car extends Vehicle &#123;</span><br><span class="line">   constructor(name) &#123;</span><br><span class="line">      super(name);</span><br><span class="line">      this.kind = &apos;car&apos;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let myCar = new Car(&apos;bumpy&apos;);</span><br><span class="line"></span><br><span class="line">myCar.getName(); // &apos;bumpy&apos;</span><br><span class="line">myCar instanceof Car; // true</span><br><span class="line">myCar instanceof Vehicle; //true</span><br></pre></td></tr></table></figure>
<p>在派生类中，可以使用super关键字来访问基类的构造函数或方法：</p>
<p>1、要访问基类构造函数，使用super()<br>2、要访问基类中的方法，是用super.getName()</p>
<p>类还有更多的用法，如果想要深入地学习这方面，可以看看Classes in ECMAScript6</p>
<h2 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h2><p>Symbol是一种新的原始数据类型，和Number、String一样。我们可以使用symbol来给对象创建唯一的ID或唯一的常量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const MY_CONSTANT = Symbol();</span><br><span class="line"></span><br><span class="line">let obj = &#123;&#125;;</span><br><span class="line">obj[MY_CONSTANT] = 1;</span><br></pre></td></tr></table></figure>
<p>注意：Object.getOwnPropertyNames方法不会返回Symbol生成键值，在for..in循环中，Object.keys()和JSON.stringify()也是不可见的，这是与普通的字符串key值的区别所在。我们可以通过Object.getOwnPropertySymbols()获取对象中的symbol数组。</p>
<p>因为不可变的特点，Symbols常常与const一起配合使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">const CHINESE = Symbol();</span><br><span class="line">const ENGLISH = Symbol();</span><br><span class="line">const SPANISH = Symbol();</span><br><span class="line"></span><br><span class="line">switch(language) &#123;</span><br><span class="line">   case CHINESE:</span><br><span class="line">      // </span><br><span class="line">      break;</span><br><span class="line">   case ENGLISH:</span><br><span class="line">      // </span><br><span class="line">      break;</span><br><span class="line">   case SPANISH:</span><br><span class="line">      // </span><br><span class="line">      break;</span><br><span class="line">   default:</span><br><span class="line">      // </span><br><span class="line">      break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以给Symbol一段字符串来描述，虽然无法通过字符串来访问symbol本身，但是调试的时候很有用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const CONST_1 = Symbol(&apos;my symbol&apos;);</span><br><span class="line">const CONST_2 = Symbol(&apos;my symbol&apos;);</span><br><span class="line"></span><br><span class="line">typeof CONST_1 === &apos;symbol&apos;; // true</span><br><span class="line"></span><br><span class="line">CONST_1 === CONST_2; // false</span><br></pre></td></tr></table></figure>
<p>想要学习更多的symbol内容可以查看symbol primitive</p>
<h2 id="Transpilation"><a href="#Transpilation" class="headerlink" title="Transpilation"></a>Transpilation</h2><p>现在我们可以使用ES6来写代码了。前面介绍中提到的浏览器还没有广泛地支持ES6的特性，而且支持性各不相同。你的用户使用的浏览器很有可能不完全懂得解析ES6代码。所以我们要将这些代码转换成上一个版本的Javascript（ES5），它们可以很好地运行在现代浏览器上，这种转换通常被称为Transpilation。在浏览器支持ES6之前，都需要在我们的应用程序中做这一项转换。</p>
<h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><p>转换代码并不困难，可以直接通过命令行转换代码，或者在Grunt和Gulp中作为一个Task包含在插件里面。有很多转换代码的方案，比如Babel，Traceur和TypeScript。可以看看这个使用Babel的例子many ways to start using ES6，很多ES6的特性都会进行处理。</p>
<p>那我们如何使用ES6呢？首先，根据你想要使用的ES6特性和你需要支持的浏览器或运行环境（比如Node.js）,在你的工作流中结合一个编译转换器。如果你希望的话，还有一些监视文件变化和浏览器实时刷新的插件来让你体验无缝的编码。</p>
<p>如果是从头开始，你可能只是想要使用命令行来转换代码（查看例子Babel CLI documentation）。如果你已经使用过grunt或gulp之类的工具，你可以添加一个比如gulp-babel的插件，或者Webpack中的babel-loader插件。对于Grunt，有一个grunt-babel，还有很多其他的ES6-related plugins。对于使用Browserify的开发者，可以看看babelify。</p>
<p>很多特性被转换成ES5的兼容性代码后，并不会有很大的开销，通过编译器提供的临时性方案会有一点点的性能损耗。你可以通过各种交互环境（也称作RELPs）来看看使用ES6代码和编译后的代码是什么样的：</p>
<ol>
<li>Traceur：website,REPL</li>
<li>Babel：website,REPL</li>
<li>TypeScript：website,REPL</li>
<li>ScratchJS（chrome插件）</li>
</ol>
<p>注意，TypeScript并不完全是一个转换器，它是强类型的Javascript的超集，可以编译成Javascript，它和其他转换器一样，支持很多ES6特性。</p>
<h3 id="究竟如何使用？"><a href="#究竟如何使用？" class="headerlink" title="究竟如何使用？"></a>究竟如何使用？</h3><p>通常来说，一些ES6的特性可以自由地使用，比如模块、箭头函数，不定参数和类。这些特性不会用太多开销，就可以转换成ES5代码。而Array、String和Math对象上和原型上的方法（比如Array.from等等）需要所谓的“polyfills”。Polyfills是对那些浏览器还没有原生支持的特性的一个临时方案。你可以首先加载polyfills，如果浏览器有此函数，代码就会正常运行，Babel和Traceur都会提供类似的polyfills。</p>
<p>可以查看ES6兼容性表来看看转换器和浏览器对ES6新特性的支持情况。令人激动的是，在写这篇文章的时候，最新的浏览器已经支持了所有ES6特性的55%到70%。Microsoft Edge，Google Chrome和Mozilla Firefox相互竞争，这对整个Web的发展有很大的意义。</p>
<p>就我个人而言，我发现能够很简单地使用ES6中的新特性，比如模块，箭头函数和不定参数等等是一种解脱，也是对自己编码的一个显著的提升。现在我很享受使用ES6写代码，然后将其转换成ES5代码。ES6的优点随着时间的增长会越来越明显。</p>
<h3 id="下一步呢？"><a href="#下一步呢？" class="headerlink" title="下一步呢？"></a>下一步呢？</h3><p>只要安装了一个转换器，就可以开始使用一些小的特性，比如let和箭头函数。记住，已经编写好的ES5代码，转换器会原封不动地保留下来。当你使用ES6去优化你的代码，慢慢地喜欢用它，你就可以逐步将越来越多的ES6特性应用到代码中。也许有一些代码会有新的模块或类语法，但是我保证一切都会越来越好的！</p>
<p>除了文章中提到的特性，还有更多的ES6的东西没有被提到，比如Map，Set，标签模板字符串，生成器，Proxy和Promise，如果你想知道请关注后续的文章。另外，如果想要深入学习，我推荐Exploring ES6这本书，书里面提到了所有的ES6特性。</p>
<h2 id="最后的思考"><a href="#最后的思考" class="headerlink" title="最后的思考"></a>最后的思考</h2><p>通过使用转换器，所有的代码实际上是转换成了ES5。而浏览器一直在添加新特性，所以，即便浏览器完全支持某个特定的ES6特性，最后还是运行ES5兼容版本的代码，这样可能表现会更糟糕。你可以期待，在你需要兼容的浏览器和运行环境里，所有的ES6特性最终都会被支持。但是在那之前，我们需要管理好这些ES6特性的支持情况，选择性地禁用某些ES6特性来减少转换成ES5代码后带来的不必要的开销。知道了这些，你就可以决定是否要使用ES6中的特性。</p>
<p>译者信息</p>
<p>小骆，90后码农一个，潜水于互联网中，专注web开发，喜爱写代码，个人博客狼狼的蓝胖子</p>
<p>译文链接：<a href="http://www.codeceo.com/article/es6-next-javascript.html" target="_blank" rel="external">http://www.codeceo.com/article/es6-next-javascript.html</a><br>英文原文：ECMAScript 6 (ES6): What’s New In The Next Version Of JavaScript</p>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/04/08/hexo新建文档后自动打开/" itemprop="url">
                  hexo新建文档后自动打开
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-04-08T18:49:48+09:00" content="2016-04-08">
              2016-04-08
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/个人/" itemprop="url" rel="index">
                    <span itemprop="name">个人</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/04/08/hexo新建文档后自动打开/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/04/08/hexo新建文档后自动打开/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>添加一篇新的文章非常简单，只需要输入下面命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new &quot;我是一篇新的文章&quot;</span><br></pre></td></tr></table></figure>
<p>就可以了。然后Hexo会自动在source/_post下面给你创建一个新的markdown文件。但是，我们每次还找到这个目录并打开这个文件才能开始编辑。虽然不是很麻烦，但是如果这个步骤能自动帮我们做的话，那是不是就完美了呢？</p>
<p>这时候，我们就需要用到Hexo支持的脚本功能。首先，我们在Hexo的目录下创建一个<code>scripts</code>文件夹，然后新增一个文件<code>autoopen.js</code>。接着我们打开<code>autoopen.js</code>后输入下面内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var exec = require(&apos;child_process&apos;).exec;</span><br><span class="line"></span><br><span class="line">// Hexo 2.x</span><br><span class="line">//hexo.on(&apos;new&apos;, function(path)&#123;</span><br><span class="line">//    exec(&apos;open &apos; + path);</span><br><span class="line">//&#125;);</span><br><span class="line"></span><br><span class="line">// Hexo 3.x</span><br><span class="line">hexo.on(&apos;new&apos;, function(data)&#123;</span><br><span class="line">    exec(&apos;open &apos; + data.path);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>因为Hexo的2.x跟3.x版本传递的参数不同，所以，请自行选择自己对应的版本来添加。</p>
<p>最后，我们依然还是输入下面的命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new &quot;我是一篇新的文章&quot;</span><br></pre></td></tr></table></figure>
<p>你会看到，markdown文件会被默认的软件给打开，这时候你只需要设置打开markdown文件的默认编辑器即可。（当然，你也可以在上面<code>exec</code>命令里面指定对应的软件）</p>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/04/08/ubuntu-服务器自动备份/" itemprop="url">
                  ubuntu-服务器自动备份
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-04-08T16:05:05+09:00" content="2016-04-08">
              2016-04-08
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/自动化/" itemprop="url" rel="index">
                    <span itemprop="name">自动化</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/04/08/ubuntu-服务器自动备份/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/04/08/ubuntu-服务器自动备份/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>目录结构</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">|-- .gitignore	#git的过滤配置文件</span><br><span class="line">|-- backup.sh		#备份脚本</span><br><span class="line">|-- db_backup		#sql保存目录</span><br><span class="line">`-- myweb			#站点</span><br></pre></td></tr></table></figure>
<p><strong>配置git</strong></p>
<p>前提，需要配置服务器上访问远程git的权限，推荐ssh密钥方式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd ~/server</span><br><span class="line">git init</span><br><span class="line">#如果需要的话，一定要记得配置.gitignore，可以讲一些不需要的文件去除掉</span><br><span class="line">git remote add origin git://example.com/example/example.git</span><br></pre></td></tr></table></figure>
<p><strong>备份脚本</strong></p>
<p>首先我们需要准备一个sh脚本，用来导出db数据跟提交到git服务器上（由于数据库内容还不多，所以现在可以考虑备份到git上面）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">#请自行替换&lt;user&gt;，&lt;password&gt;，&lt;dbName&gt;</span><br><span class="line">mysqldump --opt --user=&lt;user&gt; --password=&lt;password&gt; &lt;dbName&gt; --skip-lock-tables &gt; &quot;./db_backup/db1.sql&quot;</span><br><span class="line">mysqldump --opt --user=&lt;user&gt; --password=&lt;password&gt; &lt;dbName&gt; --skip-lock-tables &gt; &quot;./db_backup/db2.sql&quot;</span><br><span class="line"></span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;auto backup&quot;</span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure>
<p><strong>计划任务</strong></p>
<p>当然，我们配置好上面的代码之后，还不算结束。还需要配置一个定时任务，来定期执行这个<strong>备份脚本</strong>。（不然一直手动来执行的话，也会疯掉）</p>
<p>打开编辑crontab页面</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ crontab -e</span><br></pre></td></tr></table></figure>
<p>输入下列内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#backup myweb database &amp; web site</span><br><span class="line">0 1 * * * /usr/server/backup.sh</span><br></pre></td></tr></table></figure>
<p>上面的任务是每天1点的时候执行那个<code>backup.sh</code>。</p>
<p>这样，我们就可以安心的去喝茶了。。。</p>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/04/07/apns-notice/" itemprop="url">
                  APNS开发帮助
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-04-07T17:32:38+09:00" content="2016-04-07">
              2016-04-07
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/移动开发/" itemprop="url" rel="index">
                    <span itemprop="name">移动开发</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/04/07/apns-notice/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/04/07/apns-notice/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在处理iOS应用的通知时，碰到很头疼的问题。因为iOS在只有在特定条件下才会触发<code>didReceiveRemoteNotification</code>方法，目前已知的有2种情况：</p>
<ul>
<li>App在前台激活状态</li>
<li>App在后台，收到通知时点击通知栏</li>
</ul>
<p>因此，想要即使的反馈信息给用户的话，我们就需要在3个地方处理通知的问题：</p>
<ul>
<li>第一个，应用启动时从服务器端获取数据（这个不用说了）</li>
<li>第二个，应用回到前台的时判断是否需要从服务器获取数据</li>
<li>第三个，在didReceiveRemoteNotification中判断<code>application.applicationState == .Active</code>时，从服务器获取最新数据。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func application(application: UIApplication, didReceiveRemoteNotification userInfo: [NSObject : AnyObject]) &#123;</span><br><span class="line">    if ( application.applicationState == .Active )&#123;</span><br><span class="line">        //触发1</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //触发2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func applicationWillEnterForeground(application: UIApplication) &#123;</span><br><span class="line">    //触发3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>条件</th>
<th>动作</th>
<th>didReceiveRemoteNotification</th>
<th>applicationWillEnterForeground</th>
</tr>
</thead>
<tbody>
<tr>
<td>App在前台</td>
<td>收到通知</td>
<td>触发1</td>
<td>无触发</td>
</tr>
<tr>
<td>App在后台</td>
<td>收到通知，什么都不做</td>
<td>无触发</td>
<td>无触发</td>
</tr>
<tr>
<td>App在后台</td>
<td>收到通知，点击应用</td>
<td>无触发</td>
<td>触发</td>
</tr>
<tr>
<td>App在后台</td>
<td>收到通知，点击通知栏</td>
<td>触发2</td>
<td>触发</td>
</tr>
<tr>
<td>App未启动</td>
<td>收到通知，点击通知栏</td>
<td>无触发</td>
<td>无触发</td>
</tr>
<tr>
<td>App未启动</td>
<td>收到通知，点击应用</td>
<td>无触发</td>
<td>无触发</td>
</tr>
</tbody>
</table>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/04/07/angularjs-ui-route-provider/" itemprop="url">
                  AngularJS - 利用ui-route及provider实现页面数据预加载的关键
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-04-07T16:20:29+09:00" content="2016-04-07">
              2016-04-07
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/前端开发/" itemprop="url" rel="index">
                    <span itemprop="name">前端开发</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/04/07/angularjs-ui-route-provider/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/04/07/angularjs-ui-route-provider/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>我在使用angular的时候经常碰到一个问题，希望在必要数据加载完成之前暂时不要显示页面。这时，我一般用<code>ui-route</code>的<code>resolve</code>功能并结合数据接口来实现。（数据api我是一般用<code>provider</code>来封装）</p>
<p>首先，在<code>config</code>中注入<code>testProvider</code>，并非必须，只是演示下如何配置<code>provider</code>。这里有个区别就是，在config中不能直接访问<code>provider</code>的<code>$get</code>中的方法，但是可以访问<code>provider</code>对象的属性与方法。(比如下面代码中的<code>this.setPrefix</code>方法)</p>
<p>其次，然后回到我的需求部分，在ui-route里面获取需要预先加载的数据。这个跟<code>controller</code>中的注入没有区别，如例子只要在<code>resolve.userInfo</code>的方法参数上添加自己需要的<code>provider</code>名称，这里就是<code>test</code>，这样我们就可以直接调用<code>test.current</code>了。<code>resolve</code>也是一个关键，我们用它来获取数据并注入到<code>controller</code>中。</p>
<p>最后，在<code>controller</code>里面注入我们需要使用的数据，<code>userInfo</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">angular.module(&apos;logging&apos;, [])</span><br><span class="line">    .provider(&quot;test&quot;, function() &#123;</span><br><span class="line">        var prefix;</span><br><span class="line">        this.setPrefix = function(p) &#123;</span><br><span class="line">            prefix = p;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        this.$get = function() &#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                log: function(msg) &#123;</span><br><span class="line">                    console.log(prefix,msg);</span><br><span class="line">                &#125;,</span><br><span class="line">                current:function()&#123;</span><br><span class="line">                	return &#123;&quot;name&quot;:&quot;JMZ&quot;&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">angular.module(&apos;myApp&apos;, [&apos;logging&apos;]).config([&quot;$stateProvider&quot;, &quot;testProvider&quot; function ($stateProvider, testProvider) &#123;</span><br><span class="line">    testProvider.setPrefix(&quot;works: &quot;);</span><br><span class="line"></span><br><span class="line">    $stateProvider.state(&quot;home/index&quot;, &#123;</span><br><span class="line">        url: &quot;/&quot;,</span><br><span class="line">        &quot;templateUrl&quot;: &quot;home/index.tpl.html&quot;,</span><br><span class="line">        &quot;controller&quot;: &quot;home/index.ctrl&quot;</span><br><span class="line">        resolve: &#123;</span><br><span class="line">            userInfo: function ($q,test) &#123;</span><br><span class="line">                return test.current();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">&#125;]).controller(&quot;myCtrl&quot;, [&quot;$scope&quot;,&quot;test&quot;,&quot;userInfo&quot;,function($scope, test,userInfo) &#123;</span><br><span class="line">    test.log(userInfo);    </span><br><span class="line">    $scope.$watch(&apos;myModel&apos;, function(newval) &#123;</span><br><span class="line">        test.log(newval);</span><br><span class="line">    &#125;]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/04/07/gulp-guide/" itemprop="url">
                  gulp-guide
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-04-07T16:02:50+09:00" content="2016-04-07">
              2016-04-07
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/前端开发/" itemprop="url" rel="index">
                    <span itemprop="name">前端开发</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/04/07/gulp-guide/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/04/07/gulp-guide/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="gulp"><a href="#gulp" class="headerlink" title="gulp"></a>gulp</h1><p>gulp是基于Node.js的前端自动化构建工具，主要用于代码打包。目前主流的前端打包工具，grunt，gulp，webpack。grunt现在似乎慢慢被gulp取代，而我使用gulp也是冲着大家说的配置简单去的，至于通道流，运行文件什么的其实还是次要的；webpack现在很火，听说功能强大，没有用过。</p>
<p><code>npm install gulp -g</code></p>
<p>注意需要在npm全局中安装gulp，否则命令窗口中找不到gulp快捷命令，记得检查环境变量的配置情况。</p>
<h2 id="gulp-插件"><a href="#gulp-插件" class="headerlink" title="gulp 插件"></a>gulp 插件</h2><p>gulp的使用离不开gulp插件的使用，下面是常用的几款。</p>
<blockquote>
<p>npm install del gulp gulp-concat gulp-minify-css gulp-replace gulp-uglify gulp-rev gulp-rev-collector –save-dev<br>del 和 gulp-clean<br>del是node.js的插件，两者的效果相似，都是用来清除文件。至于为什么使用 del，而不是 gulp-clean，我是看到网上一篇文章推荐的。</p>
</blockquote>
<ul>
<li><p>gulp-concat</p>
<blockquote>
<p>gulp-concat用来做文件合并，可以将多个文件合并成一个文件，减少静态资源数量。</p>
</blockquote>
</li>
<li><p>gulp-minify-css</p>
<blockquote>
<p>gulp-minify-css是css的压缩工具。</p>
</blockquote>
</li>
<li><p>gulp-uglify</p>
<blockquote>
<p>gulp-uglify是js的压缩工具。官方文档上是这么写的 “Minify files with UglifyJS.”</p>
</blockquote>
</li>
<li><p>gulp-replace</p>
<blockquote>
<p>gulp-replace是一个文本修改插件，我们一般用来做文件内容的的修改，常用的是路径修改。</p>
</blockquote>
</li>
<li><p>gulp-rev和gulp-rev-collector</p>
<blockquote>
<p>gulp-rev和gulp-rev-collector，并没有用到，这里只做标示。这两个插件可以用来处理文件名，同时生成一个json文件保存修改前的文件名和修改后的文件名，并且自动处理文件中的修改，例如图片文件至于css文件。</p>
</blockquote>
</li>
</ul>
<h2 id="gulp的配置文件gulpfile-js"><a href="#gulp的配置文件gulpfile-js" class="headerlink" title="gulp的配置文件gulpfile.js"></a>gulp的配置文件gulpfile.js</h2><p>gulp依赖于配置文件gulpfile.js，在运行目录下需要手动创建gulpfile.js，gulp的任务执行代码会调用gulpfile.js。</p>
<h2 id="gulp-语法"><a href="#gulp-语法" class="headerlink" title="gulp 语法"></a>gulp 语法</h2><p>gulp的语法很简单，功能实现依赖于各种插件，所以学习上成本很低。gulp的语法其实就是是nodejs的语法。</p>
<h3 id="配置gulpfile"><a href="#配置gulpfile" class="headerlink" title="配置gulpfile"></a>配置gulpfile</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明依赖的插件</span></span><br><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"><span class="keyword">var</span> minifycss = <span class="built_in">require</span>(<span class="string">'gulp-minify-css'</span>);</span><br><span class="line"><span class="keyword">var</span> concat = <span class="built_in">require</span>(<span class="string">'gulp-concat'</span>);</span><br><span class="line"><span class="keyword">var</span> uglify = <span class="built_in">require</span>(<span class="string">'gulp-uglify'</span>);</span><br><span class="line"><span class="keyword">var</span> del = <span class="built_in">require</span>(<span class="string">'del'</span>);</span><br><span class="line"><span class="keyword">var</span> replace = <span class="built_in">require</span>(<span class="string">'gulp-replace'</span>);</span><br><span class="line"><span class="comment">//定义task</span></span><br><span class="line">gulp.task(<span class="string">'taskName'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//default是默认task，当命令行缺省调用时会执行default任务。</span></span><br><span class="line">gulp.task(<span class="string">'default'</span>, [])</span><br></pre></td></tr></table></figure>
<h3 id="命令行调用task"><a href="#命令行调用task" class="headerlink" title="命令行调用task"></a>命令行调用task</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#直接调用具体的task</span><br><span class="line">gulp taskName </span><br><span class="line">#调用默认的default，如果没用会报错</span><br><span class="line">gulp</span><br></pre></td></tr></table></figure>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//多个任务合并</span></span><br><span class="line">gulp.task(<span class="string">'default'</span>, [<span class="string">'task1'</span>, <span class="string">'task2'</span>, <span class="string">'task3'</span>, <span class="string">'task4'</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//文件拷贝语法</span></span><br><span class="line">gulp.src(<span class="string">"oldPath/images/*.*"</span>)</span><br><span class="line">    .pipe(gulp.dest(newPath+<span class="string">'/images'</span>));</span><br><span class="line">    </span><br><span class="line"><span class="comment">//文件合并且压缩语法</span></span><br><span class="line"><span class="comment">//css文件</span></span><br><span class="line">gulp.src([<span class="string">'app/assets/styles/style.css'</span>,</span><br><span class="line">          <span class="string">'app/assets/styles/public.css'</span>,</span><br><span class="line">          <span class="string">'app/assets/styles/page.css'</span>,</span><br><span class="line">          <span class="string">'app/assets/styles/jquery-ui-1.10.3.css'</span>])</span><br><span class="line">    .pipe(concat(<span class="string">'style.css'</span>))</span><br><span class="line">    .pipe(minifycss())</span><br><span class="line">    .pipe(gulp.dest(newPath));</span><br><span class="line"><span class="comment">//js文件</span></span><br><span class="line">gulp.src([</span><br><span class="line">        <span class="string">'app/components/*/*.js'</span></span><br><span class="line">    ])</span><br><span class="line">    .pipe(concat(<span class="string">'components.js'</span>))</span><br><span class="line">    .pipe(uglify())</span><br><span class="line">    .pipe(gulp.dest(newPath));</span><br><span class="line"><span class="comment">//文本修改</span></span><br><span class="line">gulp.task(<span class="string">'demo-replace'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    gulp.src(demoDir+<span class="string">'/index.html'</span>)  </span><br><span class="line">      .pipe(replace(<span class="string">'&lt;link rel="stylesheet"&gt;'</span>, <span class="string">''</span>))  <span class="comment">//删除</span></span><br><span class="line">      .pipe(replace(<span class="regexp">/\.\.\/assets\//g</span>, <span class="string">''</span>))                <span class="comment">//正则替换</span></span><br><span class="line">      .pipe(replace(<span class="regexp">/\.\.\/images/g</span>, <span class="string">'images'</span>))  </span><br><span class="line">      .pipe(gulp.dest(newPath));</span><br><span class="line"><span class="comment">//目录清理</span></span><br><span class="line">gulp.task(<span class="string">'clean'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">cb</span>)</span>&#123;</span><br><span class="line">    del(rootPath, cb);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>作者：<a href="http://my.oschina.net/u/924762/blog/628510?fromerr=0sUJ8B33" target="_blank" rel="external">http://my.oschina.net/u/924762/blog/628510?fromerr=0sUJ8B33</a></p>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/04/07/hexo-guide-1/" itemprop="url">
                  hexo教程1 - 写作
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-04-07T15:49:03+09:00" content="2016-04-07">
              2016-04-07
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/个人/" itemprop="url" rel="index">
                    <span itemprop="name">个人</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/04/07/hexo-guide-1/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/04/07/hexo-guide-1/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>你可以执行下列命令来创建一篇新文章。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure>
<p>您可以在命令中指定文章的布局（layout），默认为 <code>post</code>，可以通过修改 <code>_config.yml</code> 中的 <code>default_layout</code> 参数来指定默认布局。</p>
<h1 id="布局（Layout）"><a href="#布局（Layout）" class="headerlink" title="布局（Layout）"></a>布局（Layout）</h1><p>Hexo 有三种默认布局：<code>post</code>、<code>page</code> 和 <code>draft</code>，它们分别对应不同的路径，而您自定义的其他布局和 <code>post</code> 相同，都将储存到 <code>source/_posts</code> 文件夹。</p>
<table>
<thead>
<tr>
<th>布局</th>
<th>路径</th>
</tr>
</thead>
<tbody>
<tr>
<td>post</td>
<td>source/_posts</td>
</tr>
<tr>
<td>page</td>
<td>source</td>
</tr>
<tr>
<td>draft</td>
<td>source/_drafts</td>
</tr>
</tbody>
</table>
<h1 id="文件名称"><a href="#文件名称" class="headerlink" title="文件名称"></a>文件名称</h1><p>Hexo 默认以标题做为文件名称，但您可编辑 <code>new_post_name</code> 参数来改变默认的文件名称，举例来说，设为 <code>:year-:month-:day-:title.md</code> 可让您更方便的通过日期来管理文章。</p>
<table>
<thead>
<tr>
<th>变量</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>:title</td>
<td>标题（小写，空格将会被替换为短杠）</td>
</tr>
<tr>
<td>:year</td>
<td>建立的年份，比如， 2015</td>
</tr>
<tr>
<td>:month</td>
<td>建立的月份（有前导零），比如， 04</td>
</tr>
<tr>
<td>:i_month</td>
<td>建立的月份（无前导零），比如， 4</td>
</tr>
<tr>
<td>:day</td>
<td>建立的日期（有前导零），比如， 07</td>
</tr>
<tr>
<td>:i_day</td>
<td>建立的日期（无前导零），比如， 7</td>
</tr>
</tbody>
</table>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
               
          <p class="site-author-name" itemprop="name">ChinaJMZ</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">11</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">11</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/jmz331" target="_blank">
                  
                    <i class="fa fa-globe"></i>
                  
                  github
                </a>
              </span>
            
          
        </div>

        
        

        
        <div class="links-of-blogroll motion-element">
          
        </div>

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ChinaJMZ</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>



      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"jmz331"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
  





  
  
  

  

  

</body>
</html>
